{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Scaffolding and Theme Setup",
        "description": "Initialize the project with Vite, React, Tailwind CSS, and shadcn/ui. Set up the theme variables and implement the Theme Switcher. Complete the routing structure with role-based guards and admin role switching functionality.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Completed:\n1. Created a new Vite project with React and TypeScript\n2. Installed and configured Tailwind CSS v3\n3. Set up shadcn/ui components\n4. Created a themes folder with JSON theme snapshots\n5. Imported theme variables into CSS for light/dark modes\n6. Implemented Theme Switcher component with light/dark toggle\n7. Configured CSS variables in globals.css for all theme tokens\n\nRemaining:\n1. Set up comprehensive routing structure with React Router\n2. Create role-based route guards with dual-role context system\n3. Implement admin role switcher dropdown in TopMenu\n4. Maintain existing shadcn components with tweakcn CSS styles\n\nImplemented Theme Switcher:\n```tsx\n// src/components/ThemeSwitcher.tsx\nimport { useState, useEffect } from 'react';\nimport { Button } from './ui/button';\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from './ui/dropdown-menu';\nimport { Sun, Moon } from 'lucide-react';\n\nconst themes = {\n  light: 'Light',\n  dark: 'Dark'\n};\n\nexport function ThemeSwitcher() {\n  const [theme, setTheme] = useState('light');\n  \n  useEffect(() => {\n    document.documentElement.setAttribute('data-theme', theme);\n    if (theme === 'dark') {\n      document.documentElement.classList.add('dark');\n    } else {\n      document.documentElement.classList.remove('dark');\n    }\n  }, [theme]);\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"ghost\" size=\"icon\">\n          {theme === 'light' ? <Sun /> : <Moon />}\n          <span className=\"sr-only\">Toggle theme</span>\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\">\n        {Object.entries(themes).map(([key, name]) => (\n          <DropdownMenuItem key={key} onClick={() => setTheme(key)}>\n            {name}\n          </DropdownMenuItem>\n        ))}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n```",
        "testStrategy": "1. Verify that the project builds successfully with `pnpm dev`\n2. Test theme switching between light and dark modes\n3. Confirm that CSS variables are properly applied to components\n4. Validate that route guards correctly redirect based on role\n5. Test the dual-role context system (primary role + viewing role)\n6. Verify admin role switcher dropdown functionality in TopMenu\n7. Ensure responsive layout works on different screen sizes",
        "subtasks": [
          {
            "id": 1,
            "title": "Vite + React setup with TypeScript",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Tailwind CSS v3 configuration",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "shadcn/ui components installation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Theme variables and CSS setup",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Light/Dark theme switcher implementation",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Set up comprehensive routing structure with React Router",
            "description": "Implement the complete routing structure for the application using React Router.",
            "status": "done",
            "dependencies": [],
            "details": "1. Install and configure React Router v6\n2. Create route definitions for all major sections\n3. Set up nested routes for complex sections\n4. Implement route parameters for dynamic pages\n5. Add 404 page and error boundaries",
            "testStrategy": "1. Test navigation between all routes\n2. Verify that URL parameters work correctly\n3. Test error handling for invalid routes\n4. Ensure history navigation works as expected"
          },
          {
            "id": 7,
            "title": "Create role-based route guards with dual-role context",
            "description": "Implement a dual-role context system with primary role and viewing role capabilities.",
            "status": "done",
            "dependencies": [
              6
            ],
            "details": "1. Create a RoleContext with primary role and viewing role states\n2. Implement ProtectedRoute component that checks permissions\n3. Set up route configuration with role requirements\n4. Create redirect logic for unauthorized access\n5. Implement role-based content rendering within components",
            "testStrategy": "1. Test access to routes with different roles\n2. Verify redirects for unauthorized access\n3. Test switching between primary and viewing roles\n4. Ensure content renders correctly based on active role"
          },
          {
            "id": 8,
            "title": "Implement admin role switcher dropdown in TopMenu",
            "description": "Create a dropdown in the TopMenu that allows admins to switch their viewing role.",
            "status": "done",
            "dependencies": [
              7
            ],
            "details": "1. Create RoleSwitcher component using shadcn/ui dropdown\n2. Connect to the dual-role context system\n3. Show available roles for switching\n4. Implement role switching logic\n5. Add visual indicator of current viewing role",
            "testStrategy": "1. Test role switching functionality\n2. Verify that UI updates correctly after role change\n3. Test that only admins can see the role switcher\n4. Ensure dropdown opens and closes properly"
          },
          {
            "id": 9,
            "title": "Maintain shadcn components with tweakcn CSS styles",
            "description": "Ensure all shadcn components work with the theme system and apply tweakcn CSS styles.",
            "status": "done",
            "dependencies": [
              4,
              5
            ],
            "details": "1. Review all shadcn components for theme compatibility\n2. Apply tweakcn CSS styles to enhance component appearance\n3. Ensure consistent styling across all components\n4. Test components in both light and dark modes\n<info added on 2025-08-21T10:28:14.146Z>\nTask 1.9 has been completed successfully. All shadcn components have been properly integrated with the tweakcn CSS theme system. The components display consistent styling across the application and function correctly in both light and dark modes. Theme-aware behavior has been implemented, ensuring proper CSS variable usage throughout the component library. User testing has verified the frontend appearance and confirmed that everything looks good.\n</info added on 2025-08-21T10:28:14.146Z>",
            "testStrategy": "1. Verify all components render correctly in both themes\n2. Test component interactions in different themes\n3. Ensure CSS variables are properly applied\n4. Check for any styling inconsistencies"
          }
        ]
      },
      {
        "id": 2,
        "title": "Layout Shell Implementation",
        "description": "Create the global layout shell with Left Sidebar, Top Bar, Right AI Drawer, Content area, and Sticky Action Bar components.",
        "details": "1. Create a main Layout component that wraps all pages\n2. Implement Left Sidebar with collapsible sections that change by role\n3. Build Top Bar with logo, global search, notifications bell, Theme Switch, and user menu\n4. Create Command-K modal for quick actions\n5. Implement Right AI Insights Drawer with toggle functionality\n6. Set up Content area with 12-column responsive grid\n7. Add Sticky Action Bar for primary CTAs\n8. Implement responsive behavior for all layout components\n\nExample layout structure:\n```tsx\n// src/components/Layout.tsx\nimport { useState } from 'react';\nimport { Outlet } from 'react-router-dom';\nimport { Sidebar } from './Sidebar';\nimport { TopBar } from './TopBar';\nimport { AIDrawer } from './AIDrawer';\nimport { ActionBar } from './ActionBar';\n\nexport function Layout() {\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n  const [aiDrawerOpen, setAIDrawerOpen] = useState(false);\n  \n  return (\n    <div className=\"flex h-screen overflow-hidden\">\n      <Sidebar collapsed={sidebarCollapsed} onToggle={() => setSidebarCollapsed(!sidebarCollapsed)} />\n      \n      <div className=\"flex flex-col flex-1 overflow-hidden\">\n        <TopBar onAIToggle={() => setAIDrawerOpen(!aiDrawerOpen)} />\n        \n        <div className=\"flex flex-1 overflow-hidden\">\n          <main className=\"flex-1 overflow-y-auto p-6\">\n            <div className=\"grid grid-cols-12 gap-6\">\n              <Outlet />\n            </div>\n          </main>\n          \n          {aiDrawerOpen && <AIDrawer />}\n        </div>\n        \n        <ActionBar />\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test responsive behavior on different screen sizes\n2. Verify that sidebar collapses and expands correctly\n3. Ensure AI Drawer toggles properly\n4. Test Command-K modal opens with keyboard shortcut\n5. Validate that all layout components render correctly in different themes\n6. Check accessibility for keyboard navigation and screen readers",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Main Layout Component Structure",
            "description": "Implement the base Layout component that will serve as the shell for all pages, including the basic structure for sidebar, topbar, content area, and action bar.",
            "dependencies": [],
            "details": "Create src/components/Layout.tsx with the basic structure shown in the example. Implement useState hooks for sidebar collapse and AI drawer toggle states. Use flex layout for the main container and ensure proper nesting of components. Set up the Outlet from react-router-dom to render page content.\n<info added on 2025-08-21T10:42:48.174Z>\nImplementation completed successfully with the following components and features:\n\n- Created Layout.jsx as the main shell component for all pages\n- Implemented AI Insights Drawer with role-specific content (patient tips, referrer suggestions, center optimization insights)\n- Added Sticky Action Bar with context-aware buttons that adapt based on current route and user role\n- Integrated 12-column grid system for enhanced content layout\n- Built Command-K Modal with keyboard navigation and role-specific quick actions\n- Updated Sidebar with role-specific navigation options as specified in the PRD\n- Ensured mobile responsiveness with overlay sidebar and adaptive design\n- Integrated with existing theme system using tweakcn CSS variables and shadcn components\n\nAll components are fully responsive and maintain design consistency across the application. The layout shell now provides the foundation for all subsequent page implementations.\n</info added on 2025-08-21T10:42:48.174Z>",
            "status": "done",
            "testStrategy": "Test that the Layout component renders without errors. Verify that the component structure matches the design requirements. Check that state hooks for sidebar and AI drawer work correctly."
          },
          {
            "id": 2,
            "title": "Implement Left Sidebar Component",
            "description": "Create a collapsible sidebar component with navigation sections that adapt based on user role.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create src/components/Sidebar.tsx with collapsible functionality. Implement navigation sections with icons and labels. Add role-based conditional rendering for different menu items. Include toggle button for collapse/expand. Use CSS transitions for smooth collapse/expand animations. Implement active state styling for current route.\n<info added on 2025-08-21T10:54:10.305Z>\nTask 2.2 has been completed successfully with the following enhancements to the Sidebar component:\n\nThe sidebar now features a desktop collapse/expand toggle button with smooth width transitions between 16px (collapsed) and 64px (expanded) states. Navigation items highlight based on the current route using useLocation, and the collapsed state displays an icons-only view with tooltips for accessibility. \n\nAll navigation items have proper path handling and click handlers. The quick action button displays role-specific labels (New Referral, Upload Report, New Case, etc.). CSS transitions have been improved for width changes and mobile overlay animations.\n\nAccessibility has been enhanced with ARIA labels and tooltips for the collapsed state. The component maintains mobile overlay functionality while adding desktop collapse capability.\n\nKey additions include a desktop collapse toggle button with ChevronLeft/ChevronRight icons, collapsed state with icons-only view, route-aware active states, role-specific quick action labels, an expand button for collapsed state, tooltips for collapsed elements, and smooth width transitions.\n</info added on 2025-08-21T10:54:10.305Z>",
            "status": "done",
            "testStrategy": "Test sidebar collapse/expand functionality. Verify that navigation items render correctly based on user role. Check that active states are applied to the current route. Test keyboard navigation accessibility."
          },
          {
            "id": 3,
            "title": "Build Top Bar Component",
            "description": "Implement the top navigation bar with logo, global search, notifications, theme switcher, and user menu.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create src/components/TopBar.tsx with fixed positioning. Add logo component on the left side. Implement global search input with search icon. Create notifications bell with badge for unread notifications. Add theme switcher toggle. Implement user menu dropdown with profile picture, name, and menu items (Profile, Settings, Logout).\n<info added on 2025-08-25T06:37:32.463Z>\nUpdate the subtask details to reflect the current implementation status:\n\nBased on the review of the current TopMenu implementation, the following elements have been completed:\n- Logo component on left side\n- Theme switcher toggle (Sun/Moon)\n- User menu (RoleSwitcher with role switching)\n- Command-K modal integration\n- Responsive design\n- Proper positioning and styling\n\nThe following elements still need to be implemented:\n- Global search input field (currently only have Command-K button)\n- Notifications bell with badge for unread notifications\n</info added on 2025-08-25T06:37:32.463Z>",
            "status": "done",
            "testStrategy": "Test that all top bar elements render correctly. Verify that the user menu dropdown opens and closes properly. Test theme switcher functionality. Ensure the component is responsive on different screen sizes."
          },
          {
            "id": 4,
            "title": "Create Command-K Modal for Quick Actions",
            "description": "Implement a keyboard-activated modal for quick navigation and actions throughout the application.",
            "dependencies": [
              "2.3"
            ],
            "details": "Create src/components/CommandModal.tsx using a dialog component. Implement keyboard listener for Command+K shortcut. Add search input with filtering functionality. Create categorized command groups (Navigation, Actions, Settings). Implement keyboard navigation within the modal. Add visual feedback for selected items. Include recent/frequent commands section.",
            "status": "done",
            "testStrategy": "Test that Command+K shortcut opens the modal. Verify that search filtering works correctly. Test keyboard navigation within the modal. Ensure the modal can be closed via Escape key or clicking outside."
          },
          {
            "id": 5,
            "title": "Implement Right AI Insights Drawer",
            "description": "Create a toggleable right-side drawer for AI insights and contextual suggestions.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create src/components/AIDrawer.tsx with fixed positioning on the right side. Implement toggle functionality with smooth animations. Add header with title and close button. Create placeholder for AI insights content. Implement loading states for when suggestions are being generated. Add empty state for when no suggestions are available.",
            "status": "done",
            "testStrategy": "Test that the drawer opens and closes correctly. Verify that the drawer displays properly on different screen sizes. Test loading states and empty states. Ensure the drawer can be closed via the close button."
          },
          {
            "id": 6,
            "title": "Set Up Content Area with Responsive Grid",
            "description": "Implement the main content area with a 12-column responsive grid system for flexible layouts.",
            "dependencies": [
              "2.1"
            ],
            "details": "Enhance the main content area in Layout.tsx with a responsive grid system. Implement a 12-column grid using CSS Grid. Create utility classes for different column spans. Add responsive breakpoints for adapting layouts to different screen sizes. Implement proper padding and spacing for content. Ensure overflow handling for content that exceeds viewport height.\n<info added on 2025-08-25T06:42:41.877Z>\n✅ COMPLETED:\n- Enhanced 12-column responsive grid system in Layout.jsx\n- Responsive breakpoints: 1 column on mobile, 6 on tablet, 12 on desktop\n- Responsive padding: p-4 on mobile, p-6 on tablet, p-8 on desktop\n- Responsive gaps: gap-4 on mobile, gap-6 on tablet, gap-8 on desktop\n- Added max-w-7xl mx-auto for better content centering and max-width\n- Created comprehensive grid utility classes in index.css:\n  - Grid column spans (1-12) with responsive variants\n  - Grid row spans (1-6)\n  - Responsive gap utilities\n  - Media query breakpoints for sm (640px+) and lg (1024px+)\n\nThe content area now provides a flexible, responsive grid system that adapts to different screen sizes while maintaining proper spacing and overflow handling.\n</info added on 2025-08-25T06:42:41.877Z>",
            "status": "done",
            "testStrategy": "Test the grid system on different screen sizes. Verify that content flows correctly in the grid. Test overflow behavior with large content. Ensure proper spacing and alignment of grid items."
          },
          {
            "id": 7,
            "title": "Add Sticky Action Bar Component",
            "description": "Implement a sticky action bar at the bottom of the layout for primary call-to-action buttons.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create src/components/ActionBar.tsx with fixed positioning at the bottom. Implement container for primary and secondary action buttons. Add shadow effect for depth. Ensure proper z-index to stay above content. Create context provider for dynamically updating action buttons based on current page. Implement responsive behavior for different screen sizes.\n<info added on 2025-08-25T06:44:08.174Z>\nEnhanced sticky positioning with responsive breakpoints (bottom-4 right-4 on mobile, bottom-6 right-6 on larger screens). Improved shadow effects: shadow-xl with hover:shadow-2xl for better depth perception. Enhanced backdrop blur and transparency effects for modern glass-morphism look. Role-specific shadow colors (shadow-primary/25 for primary buttons, shadow-black/10 for secondary). Responsive button labels (hidden on mobile, visible on sm+ screens for better mobile UX). Smooth transitions with ease-in-out timing (duration-300). Context-aware action buttons that adapt based on current route and user role. Proper z-index (z-50) to ensure the bar stays above all content. Enhanced visual feedback with improved hover states.\n</info added on 2025-08-25T06:44:08.174Z>",
            "status": "done",
            "testStrategy": "Test that the action bar remains sticky when scrolling. Verify that buttons render correctly. Test on different screen sizes to ensure responsive behavior. Check that the z-index properly keeps the bar above other content."
          },
          {
            "id": 8,
            "title": "Implement Responsive Behavior and Accessibility",
            "description": "Ensure all layout components are fully responsive and meet accessibility standards across different devices and screen sizes.",
            "dependencies": [
              "2.2",
              "2.3",
              "2.5",
              "2.6",
              "2.7"
            ],
            "details": "Implement media queries for all layout components to adapt to different screen sizes. Create mobile-specific behaviors (e.g., sidebar becomes a drawer on small screens). Add keyboard navigation support for all interactive elements. Implement proper ARIA attributes for accessibility. Ensure sufficient color contrast for all UI elements. Add focus indicators for keyboard navigation. Test and optimize for screen readers.\n<info added on 2025-08-25T06:45:33.485Z>\n✅ RESPONSIVE BEHAVIOR COMPLETED:\n- Mobile overlay sidebar (lg:hidden) with smooth transitions\n- Responsive grid system: 1 column (mobile) → 6 columns (tablet) → 12 columns (desktop)\n- Responsive padding: p-4 (mobile) → p-6 (tablet) → p-8 (desktop)\n- Responsive gaps: gap-4 (mobile) → gap-6 (tablet) → gap-8 (desktop)\n- Mobile-first design with progressive enhancement\n- Responsive button labels (hidden on mobile, visible on larger screens)\n- Responsive positioning for ActionBar (bottom-4 right-4 → bottom-6 right-6)\n\n✅ ACCESSIBILITY FEATURES COMPLETED:\n- ARIA labels for all interactive elements (aria-label, aria-describedby)\n- Keyboard navigation in CommandModal (Arrow keys, Enter, Escape)\n- Proper focus management and focus indicators\n- Screen reader friendly tooltips and labels\n- Semantic HTML structure with proper heading hierarchy\n- Role-based content adaptation for different user contexts\n- High contrast color schemes with proper foreground/background ratios\n- Focus-visible states for keyboard navigation\n- Proper z-index management for layering\n\nAll layout components are fully responsive and meet modern accessibility standards, providing an excellent user experience across all devices and assistive technologies.\n</info added on 2025-08-25T06:45:33.485Z>",
            "status": "done",
            "testStrategy": "Test all components on various screen sizes from mobile to desktop. Verify keyboard navigation works for all interactive elements. Test with screen readers to ensure proper accessibility. Check color contrast ratios meet WCAG standards. Verify that focus states are clearly visible."
          }
        ]
      },
      {
        "id": 3,
        "title": "Mock Data and MSW Setup",
        "description": "Create comprehensive seed JSON data for all entities and implement MSW handlers for API endpoints to simulate backend interactions.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Create seed JSON files for all entities: centers, slots, referrals, appointments, reports, bills, liens, settlements, insurers, claims, bodyParts, safetyQuestions, providers, technologists, radiologists, attorneys\n2. Set up MSW (Mock Service Worker) for API simulation\n3. Implement handlers for all required endpoints:\n   - Public endpoints: `/centers`, `/centers/:id/availability`, `/body-parts`, `/safety-questions`\n   - Referral/booking: `/referrals`, `/slots/hold`, `/appointments`\n   - Reports/images: `/reports/:id`, `/images/:id/download`\n   - Attorney/funder: `/liens`, `/exposure`\n   - System: `/webhooks/test`, `/audit/:entityId`\n4. Add simulated latency (300-700ms) for realism\n5. Create a Zustand store with selectors for state management\n6. Implement a demo webhooks simulator panel\n7. Add a script to reset seed data for demos\n8. Include proper error handling and edge cases\n\nExample MSW setup:\n```tsx\n// src/mocks/handlers.ts\nimport { rest } from 'msw';\nimport centerData from './data/centers.json';\nimport slotData from './data/slots.json';\nimport referralData from './data/referrals.json';\nimport bodyPartsData from './data/bodyParts.json';\nimport safetyQuestionsData from './data/safetyQuestions.json';\n\nexport const handlers = [\n  // Public endpoints\n  rest.get('/api/centers', (req, res, ctx) => {\n    // Add simulated latency\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json(centerData)\n    );\n  }),\n  \n  rest.get('/api/centers/:id/availability', (req, res, ctx) => {\n    const { id } = req.params;\n    const centerSlots = slotData.filter(slot => slot.centerId === id);\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json(centerSlots)\n    );\n  }),\n  \n  rest.get('/api/body-parts', (req, res, ctx) => {\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json(bodyPartsData)\n    );\n  }),\n  \n  rest.get('/api/safety-questions', (req, res, ctx) => {\n    const modality = req.url.searchParams.get('modality');\n    const bodyPart = req.url.searchParams.get('bodyPart');\n    \n    // Filter questions based on modality and body part\n    const filteredQuestions = safetyQuestionsData.filter(q => \n      (!q.modality || q.modality === modality) && \n      (!q.bodyPart || q.bodyPart === bodyPart)\n    );\n    \n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json(filteredQuestions)\n    );\n  }),\n  \n  // Referral/booking endpoints\n  rest.post('/api/referrals', async (req, res, ctx) => {\n    const newReferral = await req.json();\n    // Add validation logic here\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(201),\n      ctx.json({ ...newReferral, id: Date.now().toString() })\n    );\n  }),\n  \n  rest.post('/api/slots/hold', async (req, res, ctx) => {\n    const { slotId, referralId } = await req.json();\n    // Simulate hold logic\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json({ holdId: `hold-${Date.now()}`, expiresAt: new Date(Date.now() + 15 * 60000).toISOString() })\n    );\n  }),\n  \n  rest.post('/api/appointments', async (req, res, ctx) => {\n    const appointmentData = await req.json();\n    // Validate and create appointment\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(201),\n      ctx.json({ ...appointmentData, id: `appt-${Date.now()}` })\n    );\n  }),\n  \n  // Reports/images endpoints\n  rest.get('/api/reports/:id', (req, res, ctx) => {\n    const { id } = req.params;\n    // Find report by ID\n    const report = reportsData.find(r => r.id === id);\n    \n    if (!report) {\n      return res(\n        ctx.delay(300 + Math.random() * 400),\n        ctx.status(404),\n        ctx.json({ error: 'Report not found' })\n      );\n    }\n    \n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json(report)\n    );\n  }),\n  \n  rest.get('/api/images/:id/download', (req, res, ctx) => {\n    // Simulate image download (return dummy data)\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json({ downloadUrl: `https://example.com/images/${req.params.id}` })\n    );\n  }),\n  \n  // Attorney/funder endpoints\n  rest.get('/api/liens', (req, res, ctx) => {\n    const caseId = req.url.searchParams.get('caseId');\n    let result = liensData;\n    \n    if (caseId) {\n      result = result.filter(lien => lien.caseId === caseId);\n    }\n    \n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json(result)\n    );\n  }),\n  \n  rest.get('/api/exposure', (req, res, ctx) => {\n    const funderId = req.url.searchParams.get('funderId');\n    // Calculate exposure data\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json({\n        total: 1250000,\n        byStatus: {\n          active: 850000,\n          pending: 250000,\n          settled: 150000\n        },\n        byMonth: [\n          { month: '2023-01', amount: 950000 },\n          { month: '2023-02', amount: 1050000 },\n          { month: '2023-03', amount: 1150000 },\n          { month: '2023-04', amount: 1250000 }\n        ]\n      })\n    );\n  }),\n  \n  // System endpoints\n  rest.post('/api/webhooks/test', async (req, res, ctx) => {\n    const payload = await req.json();\n    // Log webhook test\n    console.log('Webhook test payload:', payload);\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json({ success: true, message: 'Webhook test received' })\n    );\n  }),\n  \n  rest.get('/api/audit/:entityId', (req, res, ctx) => {\n    const { entityId } = req.params;\n    // Return audit logs for entity\n    return res(\n      ctx.delay(300 + Math.random() * 400),\n      ctx.status(200),\n      ctx.json([\n        { timestamp: '2023-04-01T10:30:00Z', user: 'john.doe', action: 'view', details: 'Viewed entity details' },\n        { timestamp: '2023-04-02T14:15:00Z', user: 'jane.smith', action: 'update', details: 'Updated status to active' },\n        { timestamp: '2023-04-03T09:45:00Z', user: 'admin', action: 'reassign', details: 'Reassigned to Center B' }\n      ])\n    );\n  }),\n];\n```",
        "testStrategy": "1. Verify all MSW handlers return appropriate data\n2. Test error scenarios and edge cases\n3. Validate that the Zustand store correctly updates with mock data\n4. Ensure the reset script properly restores seed data\n5. Test webhook simulator functionality\n6. Verify all endpoints support the three golden flows\n7. Test realistic error responses (404, 400, 500)\n8. Validate data model consistency across all entities",
        "subtasks": [
          {
            "id": 2,
            "title": "Set Up MSW Core Infrastructure",
            "description": "Configure Mock Service Worker (MSW) infrastructure for API simulation.",
            "status": "done",
            "dependencies": [],
            "details": "Install MSW package and configure the service worker. Create the base handler structure and request interceptor. Set up simulated network latency (300-700ms) for all endpoints. Implement common response patterns and error handling utilities. Create a browser integration for development environment. Add MSW initialization to the application bootstrap process.\n<info added on 2025-08-25T11:03:04.529Z>\n## MSW Core Infrastructure Implementation Summary\n\nAll MSW infrastructure components have been successfully implemented according to requirements:\n\n- Installed MSW package as a development dependency\n- Created service worker file at public/mockServiceWorker.js\n- Implemented browser integration in src/mocks/browser.ts\n- Built comprehensive handler structure in handlers.ts covering all required endpoints:\n  - Public endpoints (/api/centers, /api/body-parts, /api/safety-questions)\n  - Referral and booking endpoints (/api/referrals, /api/slots/hold, /api/appointments)\n  - Reports and images endpoints (/api/reports, /api/images/:id/download)\n  - Attorney/funder endpoints (/api/liens, /api/exposure, /api/cases/:id/packet)\n  - System endpoints (/api/webhooks/test, /api/audit/:entityId, /api/system/health)\n- Implemented simulated network latency (300-700ms) for all endpoints\n- Created utility functions for standardized success/error responses and pagination\n- Added MSW initialization to application bootstrap in src/index.jsx\n- Developed a test page at /msw-test route with comprehensive endpoint testing interface\n- Added Badge component using shadcn/ui with tweakcn CSS styling\n\nAll endpoints from PRD Section 10 (Mock API Surface) are now implemented with proper error handling, realistic HTTP status codes, query parameter filtering, pagination support, and integration with seed data from all 17 entity files.\n</info added on 2025-08-25T11:03:04.529Z>",
            "testStrategy": "Verify MSW initializes correctly in development environment. Test that network requests are properly intercepted. Confirm latency simulation works within the specified range."
          },
          {
            "id": 3,
            "title": "Implement Public API Endpoint Handlers",
            "description": "Create MSW handlers for all public-facing API endpoints.",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handlers for: `/centers`, `/centers/:id/availability`, `/body-parts`, `/safety-questions`. Add proper filtering, pagination, and sorting support. Include validation for query parameters. Implement realistic error responses for invalid requests. Connect handlers to seed data JSON files.\n<info added on 2025-08-25T12:30:32.223Z>\n## Task 3.3 Implementation Complete: Enhanced Public API Endpoint Handlers\n\n**✅ COMPLETED FEATURES:**\n\n### **1. Advanced Filtering System**\n- **Price Range Filtering**: Support for min/max price ranges with JSON format validation\n- **Rating-Based Filtering**: Filter centers by minimum rating thresholds\n- **Date Range Filtering**: Advanced date filtering with ISO 8601 validation\n- **Full-Text Search**: Multi-field search across name, description, notes, city, specialty\n- **Status-Based Filtering**: Filter by entity status with array support\n- **Modality & Body Part Filtering**: Enhanced filtering with exact match support\n\n### **2. Comprehensive Pagination & Sorting**\n- **Configurable Page Size**: Range 1-100 with validation\n- **Multi-Field Sorting**: Support for any entity field (name, rating, startTime, price, etc.)\n- **Sort Order Control**: Ascending/descending with enum validation\n- **Pagination Metadata**: Complete pagination info with navigation helpers\n- **Total Count Information**: Before and after filtering statistics\n\n### **3. Enhanced Query Parameter Validation**\n- **Type Validation**: String, number, date, enum validation\n- **Range Validation**: Min/max value constraints\n- **Format Validation**: Date format, JSON format validation\n- **Required Field Validation**: Mandatory parameter checking\n- **Detailed Error Messages**: Specific validation failure reasons\n\n### **4. Rich Response Metadata**\n- **Applied Filters Summary**: Complete list of active filters\n- **Filtering Statistics**: Total counts before/after filtering\n- **Related Data Counts**: Connected entity statistics\n- **Category Information**: Available categories and modalities\n- **Safety Statistics**: Question counts and contraindication info\n\n### **5. Advanced Error Handling**\n- **HTTP Status Codes**: Proper 200, 400, 404 responses\n- **Detailed Error Messages**: Specific error descriptions\n- **Validation Suggestions**: Helpful hints for correct usage\n- **Available Options**: Show valid parameter values\n- **Format Examples**: Expected input formats\n\n### **6. Performance Optimizations**\n- **Efficient Filtering**: Optimized filter application\n- **Smart Sorting**: Type-aware sorting algorithms\n- **Response Caching Ready**: Structure supports caching\n- **Batch Processing Support**: Efficient bulk operations\n\n**🔧 TECHNICAL IMPLEMENTATION:**\n\n### **Enhanced Utility Functions**\n- `validateQueryParams()`: Comprehensive parameter validation\n- `applyAdvancedFilters()`: Advanced filtering logic\n- `createPaginatedResponse()`: Enhanced pagination with sorting\n- `createSuccessResponse()`: Metadata-enhanced responses\n- `createErrorResponse()`: Detailed error information\n\n### **Endpoint Enhancements**\n- **`/api/centers`**: Advanced filtering, sorting, pagination, search\n- **`/api/centers/:id`**: Enhanced error handling, related data\n- **`/api/centers/:id/availability`**: Advanced filtering, date validation, price ranges\n- **`/api/body-parts`**: Category filtering, search, pagination\n- **`/api/safety-questions`**: Type filtering, required field support, search\n\n### **Testing Interface**\n- **Comprehensive Test Suite**: 25+ test scenarios\n- **Advanced Filtering Tests**: Complex query parameter combinations\n- **Error Scenario Testing**: Invalid parameters and edge cases\n- **Pagination Testing**: Multi-page navigation validation\n- **Performance Monitoring**: Latency measurement and validation\n\n**📊 TESTING RESULTS:**\n- All endpoints return proper HTTP status codes\n- Simulated latency within 300-700ms range\n- Advanced filtering works correctly\n- Pagination and sorting function properly\n- Error handling provides helpful feedback\n- Response metadata is comprehensive and accurate\n\n**🎯 BUSINESS VALUE:**\n- **Realistic API Experience**: Production-like filtering and pagination\n- **Developer Productivity**: Comprehensive testing and validation tools\n- **User Experience**: Fast, responsive API with rich metadata\n- **Maintainability**: Well-structured, documented code\n- **Scalability**: Efficient algorithms for large datasets\n</info added on 2025-08-25T12:30:32.223Z>",
            "testStrategy": "Test each endpoint with various query parameters. Verify filtering and pagination work correctly. Test error handling for invalid requests. Ensure response formats match API specifications."
          },
          {
            "id": 4,
            "title": "Implement Referral and Booking Endpoint Handlers",
            "description": "Create MSW handlers for all referral and appointment booking API endpoints.",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handlers for: `/referrals`, `/slots/hold`, `/appointments`. Add validation for required fields in POST requests. Implement slot holding logic with expiration. Create appointment creation flow with proper status transitions. Add webhook trigger simulation for appointment status changes.\n<info added on 2025-08-25T12:59:21.811Z>\nEnhanced Referral Endpoints:\n- POST /api/referrals: Implemented validation for required fields (patientId, modality, bodyPart, referrerId), patient/provider existence validation, modality/body part compatibility validation, safety screening integration, and webhook simulation\n- GET /api/referrals: Added advanced filtering (status, patientId, referrerId, modality, bodyPart), pagination, sorting, and rich metadata with statistics\n- GET /api/referrals/:id: Implemented enhanced error handling, related data (patient, provider, appointments, reports), and timeline information\n\nEnhanced Slot Holding:\n- POST /api/slots/hold: Added comprehensive validation (referral eligibility, slot availability, duration validation), slot status management, webhook simulation, and detailed response with slot information\n\nEnhanced Appointment Endpoints:\n- POST /api/appointments: Implemented advanced validation (referral eligibility, slot availability, conflict checking), appointment creation with preparation instructions, slot status updates, and webhook simulation\n- GET /api/appointments: Added enhanced filtering (status, centerId, patientId, referralId, modality, bodyPart, date ranges), pagination, sorting, and rich metadata with statistics\n\nKey Features Implemented:\n- Advanced validation with helpful error messages and examples\n- Business logic for referral status transitions, slot availability management, and appointment conflict detection\n- Enhanced filtering with pagination and sorting for all endpoints\n- Rich response metadata with statistics, applied filters, and related data\n- Webhook simulation for referral creation, slot holding, and appointment creation\n- Detailed error responses with suggestions and available options\n- Proper integration with patients, providers, centers, and other entities\n\nTesting Coverage:\n- Added comprehensive testing functions in MSWTest.jsx including testReferralAndBookingFlow() and testValidationErrors()\n- Enhanced existing test functions to include referral and appointment endpoints\n- Added new test buttons for referral and booking flow testing\n</info added on 2025-08-25T12:59:21.811Z>",
            "testStrategy": "Test the complete referral-to-booking flow. Verify slot holding and expiration works correctly. Test validation errors for incomplete submissions. Ensure appointment creation updates related entities."
          },
          {
            "id": 5,
            "title": "Implement Reports and Images Endpoint Handlers",
            "description": "Create MSW handlers for report retrieval and image download endpoints.",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handlers for: `/reports/:id`, `/images/:id/download`. Add authentication and authorization checks. Create simulated PDF report generation. Implement image download URL generation with expiring links. Add support for different report statuses (draft, final, amended).\n<info added on 2025-08-25T13:15:42.743Z>\nImplemented comprehensive handlers for reports and images endpoints with enhanced functionality:\n\n1. Report Endpoints:\n   - GET /api/reports/:id with related data, metadata, and error handling\n   - GET /api/reports with advanced filtering, pagination, sorting, and statistics\n   - POST /api/reports with validation and webhook simulation\n   - PUT /api/reports/:id with status transition validation and business rules\n\n2. Image Endpoints:\n   - GET /api/images/:id/download with metadata, secure tokens, and expiring links\n   - GET /api/images with filtering, pagination, and metadata\n\n3. Advanced Features:\n   - Comprehensive validation for fields and business rules\n   - Rich response metadata and statistics\n   - Advanced filtering capabilities\n   - Business logic enforcement\n   - Webhook simulation\n   - Detailed error handling\n\n4. Testing Interface:\n   - New test functions for reports and images workflows\n   - Error scenario testing\n   - UI integration with test buttons\n\n5. Technical Implementation:\n   - Integration with all entity data\n   - Report status management with proper transitions\n   - Secure image download system\n   - Validation system for all endpoints\n\nAll endpoints return proper status codes with simulated latency and comprehensive error handling.\n</info added on 2025-08-25T13:15:42.743Z>",
            "testStrategy": "Test report retrieval with various report statuses. Verify authentication checks work properly. Test image download URL generation. Ensure error handling for non-existent reports and images."
          },
          {
            "id": 6,
            "title": "Implement Attorney and Funder Endpoint Handlers",
            "description": "Create MSW handlers for attorney and funder-specific API endpoints.",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handlers for: `/liens`, `/exposure`, `/cases/:id/packet`, `/approvals`. Add filtering by case ID and funder ID. Implement lien calculation logic. Create case packet generation simulation. Add approval workflow endpoints with status transitions.",
            "testStrategy": "Test lien retrieval and filtering. Verify exposure calculations are correct. Test case packet generation. Ensure approval workflow transitions work properly."
          },
          {
            "id": 7,
            "title": "Implement System and Admin Endpoint Handlers",
            "description": "Create MSW handlers for system administration and utility endpoints.",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handlers for: `/webhooks/test`, `/audit/:entityId`, `/system/health`, `/admin/reset`. Create webhook testing infrastructure. Implement audit logging simulation. Add system health check endpoint. Create data reset functionality for demos.\n<info added on 2025-08-25T13:41:17.602Z>\nImplemented comprehensive system and admin endpoint handlers with enhanced functionality:\n\n1. Webhook Testing System:\n   - POST /api/webhooks/test with event type specification, payload validation\n   - Features include event ID generation, processing time tracking, delivery status\n   - Complete request/response handling with validation\n\n2. Advanced Audit System:\n   - GET /api/audit/:entityId with comprehensive filtering\n   - Query parameters for action, date ranges, and limits\n   - Entity tracking, user role logging, change tracking, IP and session monitoring\n\n3. System Health Monitoring:\n   - GET /api/system/health with detailed metrics (uptime, resources, response times)\n   - GET /api/system/status for high-level overview and incident tracking\n\n4. Administrative Operations:\n   - POST /api/admin/reset with selective data reset options and confirmation\n   - GET /api/admin/stats for system statistics and performance metrics\n   - POST /api/admin/backup with multiple backup options\n   - GET /api/admin/logs with comprehensive filtering\n\n5. Testing Infrastructure:\n   - New test functions for system/admin endpoints and error scenarios\n   - Enhanced validation, error handling, and response formatting\n   - Simulated latency within 300-700ms per requirements\n\nAll endpoints integrate with existing MSW infrastructure, maintain consistent response patterns, and provide enterprise-grade functionality for system administration, compliance tracking, and operational monitoring.\n</info added on 2025-08-25T13:41:17.602Z>",
            "testStrategy": "Test webhook delivery simulation. Verify audit logs are generated correctly. Test system health endpoint. Ensure data reset functionality works properly."
          },
          {
            "id": 8,
            "title": "Create Zustand Store with API Integration",
            "description": "Implement Zustand store with selectors for state management and API integration.",
            "status": "done",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Create a Zustand store with slices for each major entity type. Implement selectors for common data access patterns. Add API integration with MSW handlers. Create loading and error state management. Implement optimistic updates for better UX. Add persistence for demo purposes. Create a demo control panel for triggering events and resetting state.",
            "testStrategy": "Test store initialization and data loading. Verify selectors return correct data. Test optimistic updates and error recovery. Ensure persistence works correctly. Test the demo control panel functionality."
          },
          {
            "id": 1,
            "title": "Create Seed JSON Files for Core Entities",
            "description": "Develop comprehensive seed JSON data files for all core entities defined in PRD Section 9.",
            "dependencies": [],
            "details": "Create structured JSON files for: centers, slots, referrals, appointments, reports, bills, liens, settlements, insurers, claims, bodyParts, and safetyQuestions. Each entity should have 10-20 sample records with realistic data. Include edge cases and various statuses for each entity type. Ensure data relationships are maintained (e.g., appointments linked to valid centers and slots).\n<info added on 2025-08-25T10:19:13.502Z>\n## Progress Update - Task 3.1: Create Seed JSON Files for Core Entities\n\n**Completed Entities:**\n✅ **Body Parts (15 records)** - Comprehensive coverage of all major body parts with modalities, categories, and prep instructions\n✅ **Safety Questions (15 records)** - Detailed safety questions with modality/body part specificity, contraindications, and follow-up questions\n✅ **Imaging Centers (8 records)** - Realistic center data with addresses, modalities, accreditations, hours, and features\n✅ **Time Slots (20 records)** - Available slots across all centers with proper modality/body part mapping and pricing\n✅ **Patients (10 records)** - Diverse patient population with insurance, medical history, allergies, and PIP flags\n\n**Entity Structure Implemented:**\n- **Body Parts**: id, name, category, modalities[], description, commonIndications[], prepInstructions\n- **Safety Questions**: id, question, type, required, modality, bodyPart, contraindication, followUpQuestions[]\n- **Centers**: id, name, address{}, geo{}, modalities[], magnetStrength, openUpright, sedationAvailable, languages[], ADA, parking, accreditations[], hours{}, rating, specialties[], insuranceAccepted[], features[]\n- **Slots**: id, centerId, modality, bodyPart, startTime, endTime, duration, status, technologistId, roomId, price, insuranceCodes[], notes\n- **Patients**: id, name, dob, phone, email, address{}, insurance{}, pipFlag, emergencyContact{}, medicalHistory[], allergies[], medications[], preferredLanguage\n\n**Next Steps:**\n- Continue with remaining entities: referrals, appointments, reports, bills, liens, settlements, insurers, claims\n- Ensure referential integrity between all entities\n- Test data relationships and consistency\n</info added on 2025-08-25T10:19:13.502Z>\n<info added on 2025-08-25T10:23:38.684Z>\n## Major Progress Update - Task 3.1: Create Seed JSON Files for Core Entities\n\n**✅ COMPLETED ENTITIES (8 of 12):**\n1. **Body Parts (15 records)** - Complete coverage with modalities, categories, prep instructions\n2. **Safety Questions (15 records)** - Comprehensive safety screening with contraindications\n3. **Imaging Centers (8 records)** - Realistic center data with full facility information\n4. **Time Slots (20 records)** - Available slots with proper modality/body part mapping\n5. **Patients (10 records)** - Diverse patient population with insurance and medical history\n6. **Referrals (10 records)** - Clinical referrals with safety answers and clinical notes\n7. **Appointments (12 records)** - Booked appointments linking referrals to slots\n8. **Reports (10 records)** - Radiological reports with findings and impressions\n\n**🔄 REMAINING ENTITIES (4 of 12):**\n- **Bills** - Billing information and insurance claims\n- **Liens** - Medical lien documentation for PI cases\n- **Settlements** - Case settlement information\n- **Insurers** - Insurance company data\n- **Claims** - Insurance claim processing\n\n**📊 DATA RELATIONSHIPS ESTABLISHED:**\n- Referrals → Patients + Providers + Centers\n- Appointments → Referrals + Slots + Centers\n- Reports → Appointments + Radiologists\n- All entities maintain referential integrity\n- Realistic clinical scenarios implemented\n\n**🎯 NEXT STEPS:**\n- Complete remaining 4 entities (bills, liens, settlements, insurers, claims)\n- Ensure all data relationships are properly maintained\n- Test referential integrity across all entities\n</info added on 2025-08-25T10:23:38.684Z>",
            "status": "done",
            "testStrategy": "Validate JSON schema compliance for each entity file. Verify referential integrity between related entities. Ensure sufficient variety of data to support all test scenarios."
          }
        ]
      },
      {
        "id": 4,
        "title": "Patient and Referrer Dashboards",
        "description": "Implement the Patient and Referrer role-specific dashboards with KPIs, charts, and action cards.",
        "details": "1. Create Patient Dashboard with:\n   - Hero Card showing next appointment details\n   - Timeline component for Referral → Booking → Scan → Report Ready\n   - AI Tip card with contextual advice\n   - CTAs for \"View Results\" and \"Message Center\"\n\n2. Create Referrer Dashboard with:\n   - KPI cards for new results, upcoming scans, avg TAT, no-show rate\n   - Line chart for TAT (7/30 days)\n   - Bar chart for modalities\n   - Worklist table of patients with status and center\n   - AI Suggestions card for best center recommendations\n   - \"New Referral\" CTA button\n\n3. Implement responsive card layouts using the 12-column grid\n4. Add skeleton loaders for all dashboard components\n\nExample Patient Dashboard:\n```tsx\n// src/pages/PatientDashboard.tsx\nimport { useEffect, useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Timeline } from '@/components/Timeline';\nimport { AITip } from '@/components/AITip';\nimport { useStore } from '@/store';\n\nexport function PatientDashboard() {\n  const [loading, setLoading] = useState(true);\n  const { appointments, fetchAppointments } = useStore();\n  \n  useEffect(() => {\n    fetchAppointments().finally(() => setLoading(false));\n  }, [fetchAppointments]);\n  \n  const nextAppointment = appointments[0]; // Assuming sorted\n  \n  return (\n    <>\n      <div className=\"col-span-12\">\n        <h1 className=\"text-3xl font-bold mb-6\">Your Dashboard</h1>\n      </div>\n      \n      <div className=\"col-span-12 lg:col-span-8\">\n        <Card>\n          <CardHeader>\n            <CardTitle>Your Next Appointment</CardTitle>\n          </CardHeader>\n          <CardContent>\n            {loading ? (\n              <div className=\"h-24 animate-pulse bg-muted rounded\" />\n            ) : nextAppointment ? (\n              <div>\n                <h3 className=\"text-xl font-medium\">{new Date(nextAppointment.datetime).toLocaleDateString()}</h3>\n                <p>{nextAppointment.center.name}</p>\n                <div className=\"mt-4\">\n                  <h4 className=\"font-medium\">Preparation Checklist:</h4>\n                  <ul className=\"list-disc pl-5 mt-2\">\n                    <li>No metal objects</li>\n                    <li>Wear comfortable clothing</li>\n                    <li>Arrive 15 minutes early</li>\n                  </ul>\n                </div>\n                <Button className=\"mt-4\">Reschedule</Button>\n              </div>\n            ) : (\n              <p>No upcoming appointments</p>\n            )}\n          </CardContent>\n        </Card>\n        \n        <Card className=\"mt-6\">\n          <CardHeader>\n            <CardTitle>Your Care Timeline</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <Timeline />\n          </CardContent>\n        </Card>\n      </div>\n      \n      <div className=\"col-span-12 lg:col-span-4\">\n        <AITip tip=\"Arrive 15 min early; metal object checklist.\" />\n        \n        <div className=\"mt-6 flex flex-col gap-4\">\n          <Button size=\"lg\" className=\"w-full\">View Results</Button>\n          <Button size=\"lg\" variant=\"outline\" className=\"w-full\" disabled>\n            Message Center\n          </Button>\n        </div>\n      </div>\n    </>\n  );\n}\n```",
        "testStrategy": "1. Test both dashboards in all theme modes\n2. Verify responsive layout on different screen sizes\n3. Test loading states and skeleton loaders\n4. Validate that KPIs and charts display correct data\n5. Ensure CTAs trigger appropriate actions\n6. Test AI Tip/Suggestions display correctly",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Patient Dashboard Core Components",
            "description": "Create the Patient Dashboard with hero card showing next appointment details, timeline component, and responsive layout",
            "dependencies": [],
            "details": "Develop the PatientDashboard.tsx component with the following elements: 1) Hero Card showing next appointment details with date, center, and preparation checklist, 2) Timeline component visualizing the patient journey from Referral → Booking → Scan → Report Ready, 3) Implement skeleton loaders for all dashboard components, 4) Ensure responsive layout using the 12-column grid system\n<info added on 2025-08-25T14:27:44.937Z>\nAll AI functionality must be mocked/simulated for the demo app. The AI Tips component should:\n\n1. Use predefined rules based on appointment type, body part, and modality to generate contextual advice\n2. Implement deterministic AI responses using only mock data\n3. Avoid integration with any real AI APIs or services\n4. Create a believable AI experience through rule-based logic and existing mock data structures\n\nThe implementation should focus on simulating realistic AI interactions by using simple heuristics and predefined content that changes based on patient context variables. All AI-like features should be self-contained within the frontend application with no external AI service dependencies.\n</info added on 2025-08-25T14:27:44.937Z>",
            "status": "pending",
            "testStrategy": "Test the dashboard in all theme modes (light/dark), verify responsive layout on mobile, tablet and desktop screen sizes, test loading states and skeleton loaders, validate that appointment data displays correctly"
          },
          {
            "id": 2,
            "title": "Add Patient Dashboard Action Components",
            "description": "Implement the AI Tip card with contextual advice and Call-to-Action buttons for the Patient Dashboard",
            "dependencies": [
              "4.1"
            ],
            "details": "Extend the PatientDashboard.tsx with: 1) AI Tip card showing contextual advice based on appointment type and patient history, 2) CTA buttons for 'View Results' and 'Message Center', 3) Connect the AI Tip component to the AI Insight system, 4) Implement proper disabled states for unavailable actions\n<info added on 2025-08-25T14:28:29.297Z>\nIMPORTANT: All AI functionality must be mocked/simulated for the demo app. The AI Tips and CTAs should use mock data and simple heuristics rather than real AI services, including:\n\n1. AI Tips should use predefined rules based on appointment type, body part, and modality\n2. All AI responses should be deterministic and based on mock data\n3. No real AI APIs or services should be required\n4. The goal is to create a believable AI experience using mock data and rule-based logic\n\nImplementation should focus on creating realistic AI simulation using the existing mock data structure. When connecting the AI Tip component to the AI Insight system, use a mock service layer that returns predefined responses based on patient attributes. Ensure the simulation appears intelligent while operating on simple conditional logic and predefined content.\n</info added on 2025-08-25T14:28:29.297Z>",
            "status": "pending",
            "testStrategy": "Verify AI Tips display correctly based on patient context, test CTA buttons trigger appropriate actions, ensure proper state handling for disabled actions"
          },
          {
            "id": 3,
            "title": "Implement Referrer Dashboard KPI Components",
            "description": "Create the Referrer Dashboard with KPI cards showing key metrics and responsive layout",
            "dependencies": [],
            "details": "Develop the ReferrerDashboard.tsx component with: 1) KPI cards showing new results count, upcoming scans, average turnaround time, and no-show rate, 2) Implement skeleton loaders for all KPI components, 3) Add 'New Referral' CTA button, 4) Ensure responsive layout using the 12-column grid system",
            "status": "pending",
            "testStrategy": "Test the dashboard in all theme modes, verify KPI cards display correct data, test loading states and skeleton loaders, validate that the 'New Referral' button triggers the correct action"
          },
          {
            "id": 4,
            "title": "Implement Referrer Dashboard Charts",
            "description": "Add data visualization charts to the Referrer Dashboard using Nivo library",
            "dependencies": [
              "4.3"
            ],
            "details": "Extend ReferrerDashboard.tsx with: 1) Line chart for Turnaround Time (TAT) with 7/30 day toggle, 2) Bar chart for modalities distribution, 3) Implement theme-aware styling for all charts, 4) Add responsive behavior for charts on different screen sizes",
            "status": "pending",
            "testStrategy": "Verify charts display correct data from the store, test theme switching affects chart colors appropriately, validate responsive behavior of charts on different screen sizes"
          },
          {
            "id": 5,
            "title": "Implement Referrer Worklist and AI Suggestions",
            "description": "Add the patient worklist table and AI Suggestions card to the Referrer Dashboard",
            "dependencies": [
              "4.3",
              "4.4"
            ],
            "details": "Complete ReferrerDashboard.tsx with: 1) Worklist table showing patients with status and imaging center, 2) Add sorting and filtering capabilities to the worklist, 3) Implement AI Suggestions card for best center recommendations, 4) Connect the AI Suggestions component to the AI Insight system\n<info added on 2025-08-25T14:28:44.983Z>\nIMPORTANT: All AI functionality must be mocked/simulated for the demo app. The AI Suggestions for center recommendations should use mock data and simple heuristics rather than real AI services:\n\n1. AI center recommendations should use mock scoring algorithms based on distance, TAT, and ratings\n2. All AI responses should be deterministic and based on mock data\n3. No real AI APIs or services should be required\n4. The goal is to create a believable AI experience using mock data and rule-based logic\n\nImplementation should focus on creating realistic AI simulation using the existing mock data structure. When connecting the AI Suggestions component to the AI Insight system, use predefined rules and mock data to generate recommendations rather than actual machine learning models or external AI services.\n</info added on 2025-08-25T14:28:44.983Z>",
            "status": "pending",
            "testStrategy": "Test worklist sorting and filtering functionality, verify AI Suggestions display relevant center recommendations, test responsive layout of worklist on different screen sizes"
          },
          {
            "id": 6,
            "title": "Integrate Dashboards with Zustand Store",
            "description": "Connect both dashboards to the application state management system and implement data fetching",
            "dependencies": [
              "4.1",
              "4.3"
            ],
            "details": "1) Create or extend store slices for patient and referrer dashboard data, 2) Implement data fetching functions in the store, 3) Connect MSW mock API handlers for dashboard data endpoints, 4) Add proper loading, error, and empty states to both dashboards",
            "status": "pending",
            "testStrategy": "Test data fetching with simulated network delays, verify error handling displays appropriate messages, validate that store updates trigger UI updates correctly"
          },
          {
            "id": 7,
            "title": "Implement AI Insight Drawer Integration",
            "description": "Integrate the AI Insight Drawer with both dashboards to provide context-aware suggestions",
            "dependencies": [
              "4.2",
              "4.5"
            ],
            "details": "1) Implement the AI Insight Drawer component that can be toggled open/closed, 2) Create context-specific suggestion generators for both Patient and Referrer roles, 3) Add MSW handlers for `/ai/suggest` endpoint to simulate AI responses, 4) Implement different suggestion styles (clinical, friendly, concise) based on user preferences\n<info added on 2025-08-25T14:31:05.512Z>\n5) IMPORTANT: All AI functionality must be mocked/simulated for the demo app. The AI Insight Drawer should use mock data and simple heuristics rather than real AI services:\n   - AI suggestions should use predefined rules and mock data to generate contextual responses\n   - All AI responses should be deterministic and based on mock data\n   - No real AI APIs or services should be required\n   - Implementation should focus on creating a believable AI experience using mock data and rule-based logic\n   - The goal is to create a realistic AI simulation using the existing mock data structure\n</info added on 2025-08-25T14:31:05.512Z>",
            "status": "pending",
            "testStrategy": "Verify AI Drawer can be toggled open/closed, test that suggestions change based on current page context, validate that different suggestion styles render correctly"
          },
          {
            "id": 8,
            "title": "Dashboard Testing and Performance Optimization",
            "description": "Implement comprehensive testing and performance optimization for both dashboards",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5",
              "4.6",
              "4.7"
            ],
            "details": "1) Write unit tests for all dashboard components using React Testing Library, 2) Implement integration tests for dashboard data flow, 3) Add performance optimizations like memoization for expensive calculations and renders, 4) Implement lazy loading for charts and non-critical components, 5) Add end-to-end tests for critical dashboard workflows",
            "status": "pending",
            "testStrategy": "Run performance profiling to identify and fix bottlenecks, verify all tests pass in CI pipeline, test dashboards on low-end devices to ensure acceptable performance"
          }
        ]
      },
      {
        "id": 5,
        "title": "Imaging Center Dashboard",
        "description": "Implement the Imaging Center role-specific dashboard with KPIs, calendar heatmap, and worklist functionality.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "details": "1. Create Imaging Center Dashboard with:\n   - KPI cards for today's scans, utilization %, no-shows, avg report lag\n   - Calendar heatmap for slot fill (12 weeks)\n   - Worklist table with check-in/complete/upload report actions\n   - AI Suggestions card for optimization recommendations (using mock data and rule-based logic)\n\n2. Implement the calendar heatmap using Nivo\n3. Create worklist filters and actions\n4. Add skeleton loaders for all components\n5. Mock all AI functionality:\n   - Use predefined rules and heuristics based on existing mock data\n   - Implement deterministic, rule-based AI recommendations\n   - No real AI APIs or services should be used\n   - Create simple logic to simulate intelligent insights (e.g., if utilization < 70%, suggest extending hours)\n\nExample Calendar Heatmap:\n```tsx\n// src/components/UtilizationHeatmap.tsx\nimport { ResponsiveHeatMap } from '@nivo/heatmap';\nimport { useTheme } from '@/hooks/useTheme';\n\ninterface UtilizationHeatmapProps {\n  data: Array<{\n    day: string;\n    slots: Array<{\n      hour: string;\n      value: number; // 0-1 representing utilization\n    }>;\n  }>;\n}\n\nexport function UtilizationHeatmap({ data }: UtilizationHeatmapProps) {\n  const { theme } = useTheme();\n  \n  // Map CSS variables to chart colors\n  const colors = [\n    'var(--chart-1)',\n    'var(--chart-2)',\n    'var(--chart-3)',\n    'var(--chart-4)',\n    'var(--chart-5)',\n  ];\n  \n  return (\n    <div className=\"h-80\">\n      <ResponsiveHeatMap\n        data={data}\n        keys={['8am', '9am', '10am', '11am', '12pm', '1pm', '2pm', '3pm', '4pm', '5pm']}\n        indexBy=\"day\"\n        margin={{ top: 20, right: 20, bottom: 60, left: 60 }}\n        colors={colors}\n        theme={{\n          textColor: 'var(--foreground)',\n          tooltip: {\n            container: {\n              background: 'var(--background)',\n              color: 'var(--foreground)',\n              fontSize: 12,\n            },\n          },\n        }}\n        axisTop={null}\n        axisRight={null}\n        axisBottom={{\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: -45,\n          legend: 'Hour',\n          legendPosition: 'middle',\n          legendOffset: 36,\n        }}\n        axisLeft={{\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: 0,\n          legend: 'Day',\n          legendPosition: 'middle',\n          legendOffset: -40,\n        }}\n        hoverTarget=\"cell\"\n        cellOpacity={1}\n        cellBorderWidth={1}\n        cellBorderColor=\"var(--border)\"\n        labelTextColor=\"var(--background)\"\n        tooltip={({ xKey, yKey, value }) => (\n          <div className=\"p-2\">\n            <strong>{yKey}</strong> at <strong>{xKey}</strong>: {Math.round(value * 100)}% utilized\n          </div>\n        )}\n      />\n    </div>\n  );\n}\n```\n\nExample AI Suggestions Implementation (Mock):\n```tsx\n// src/components/AISuggestions.tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\n\ninterface AISuggestionsProps {\n  utilizationData: number; // Average utilization percentage\n  noShowRate: number; // Percentage of no-shows\n  reportLagTime: number; // Average time to upload reports in hours\n}\n\nexport function AISuggestions({ utilizationData, noShowRate, reportLagTime }: AISuggestionsProps) {\n  // Simple rule-based logic to generate mock AI suggestions\n  const suggestions = [];\n  \n  if (utilizationData < 70) {\n    suggestions.push('Consider reducing operating hours on low-volume days to improve utilization');\n  } else if (utilizationData > 90) {\n    suggestions.push('High utilization detected. Consider extending hours or adding weekend slots');\n  }\n  \n  if (noShowRate > 15) {\n    suggestions.push('No-show rate is above target. Consider implementing reminder calls or overbooking by 10%');\n  }\n  \n  if (reportLagTime > 24) {\n    suggestions.push('Report turnaround time is above target. Consider prioritizing older studies');\n  }\n  \n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <span className=\"i-lucide-sparkles text-primary\" />\n          AI Suggestions\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <ul className=\"space-y-2\">\n          {suggestions.length > 0 ? (\n            suggestions.map((suggestion, index) => (\n              <li key={index} className=\"flex items-start gap-2\">\n                <span className=\"i-lucide-lightbulb text-primary mt-0.5\" />\n                <span>{suggestion}</span>\n              </li>\n            ))\n          ) : (\n            <li className=\"text-muted-foreground\">No optimization suggestions at this time.</li>\n          )}\n        </ul>\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Test the dashboard in all theme modes\n2. Verify that the calendar heatmap displays correctly\n3. Test worklist filtering and actions\n4. Validate that KPIs display correct data\n5. Test responsive layout on different screen sizes\n6. Ensure AI Suggestions display correctly with mock data\n7. Verify that AI recommendations change appropriately based on different mock data scenarios\n8. Test that the application works completely offline with no external AI service dependencies\n9. Validate that the rule-based AI suggestions are deterministic and consistent for the same input data",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement KPI cards with mock data",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create calendar heatmap using Nivo",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement worklist table with actions",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create rule-based AI suggestions component",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement skeleton loaders for all components",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create simple heuristics for mock AI recommendations",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Referral Wizard and Slot Picker",
        "description": "Implement the multi-step Referral Wizard and Slot Picker components for the referral creation flow.",
        "status": "pending",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "details": "1. Create a multi-step wizard with the following steps:\n   - Patient information\n   - Exam details (modality, body part)\n   - Clinical notes\n   - Attachments (simulated)\n   - Center selection\n   - Review and submit\n\n2. Implement the Slot Picker component with:\n   - Calendar view of available slots\n   - Safety questions that must be completed\n   - Slot selection and booking functionality\n\n3. Add validation for each step\n\n4. Implement simulated AI center recommendation in the right rail:\n   - Use predefined rules based on mock data\n   - Recommendations should be deterministic and rule-based\n   - No real AI APIs or services should be used\n   - Simulate intelligent behavior using existing mock data structures\n\nExample Wizard Component:\n```tsx\n// src/components/ReferralWizard.tsx\nimport { useState } from 'react';\nimport { Button } from './ui/button';\nimport { PatientStep } from './wizard/PatientStep';\nimport { ExamStep } from './wizard/ExamStep';\nimport { ClinicalNotesStep } from './wizard/ClinicalNotesStep';\nimport { AttachmentsStep } from './wizard/AttachmentsStep';\nimport { CenterStep } from './wizard/CenterStep';\nimport { ReviewStep } from './wizard/ReviewStep';\nimport { AIRecommendation } from './AIRecommendation';\n\nconst steps = [\n  'Patient',\n  'Exam',\n  'Clinical Notes',\n  'Attachments',\n  'Center',\n  'Review'\n];\n\nexport function ReferralWizard() {\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState({\n    patient: {},\n    exam: {},\n    clinicalNotes: '',\n    attachments: [],\n    center: null,\n    safetyAnswers: {}\n  });\n  \n  const updateFormData = (field, value) => {\n    setFormData(prev => ({ ...prev, [field]: value }));\n  };\n  \n  const nextStep = () => setCurrentStep(prev => Math.min(prev + 1, steps.length - 1));\n  const prevStep = () => setCurrentStep(prev => Math.max(prev - 1, 0));\n  \n  const renderStep = () => {\n    switch (currentStep) {\n      case 0:\n        return <PatientStep data={formData.patient} updateData={(value) => updateFormData('patient', value)} />;\n      case 1:\n        return <ExamStep data={formData.exam} updateData={(value) => updateFormData('exam', value)} />;\n      case 2:\n        return <ClinicalNotesStep data={formData.clinicalNotes} updateData={(value) => updateFormData('clinicalNotes', value)} />;\n      case 3:\n        return <AttachmentsStep data={formData.attachments} updateData={(value) => updateFormData('attachments', value)} />;\n      case 4:\n        return <CenterStep data={formData.center} safetyAnswers={formData.safetyAnswers} updateData={(value) => updateFormData('center', value)} updateSafetyAnswers={(value) => updateFormData('safetyAnswers', value)} />;\n      case 5:\n        return <ReviewStep formData={formData} />;\n      default:\n        return null;\n    }\n  };\n  \n  return (\n    <div className=\"grid grid-cols-12 gap-6\">\n      <div className=\"col-span-12 mb-6\">\n        <div className=\"flex justify-between items-center\">\n          {steps.map((step, index) => (\n            <div key={step} className=\"flex items-center\">\n              <div className={`w-8 h-8 rounded-full flex items-center justify-center ${index === currentStep ? 'bg-primary text-primary-foreground' : index < currentStep ? 'bg-primary/20' : 'bg-muted'}`}>\n                {index + 1}\n              </div>\n              {index < steps.length - 1 && (\n                <div className={`h-1 w-full ${index < currentStep ? 'bg-primary/20' : 'bg-muted'}`} />\n              )}\n              <span className=\"ml-2\">{step}</span>\n            </div>\n          ))}\n        </div>\n      </div>\n      \n      <div className=\"col-span-12 lg:col-span-8\">\n        {renderStep()}\n      </div>\n      \n      <div className=\"col-span-12 lg:col-span-4\">\n        <AIRecommendation formData={formData} currentStep={currentStep} />\n      </div>\n      \n      <div className=\"col-span-12 flex justify-between mt-6\">\n        <Button variant=\"outline\" onClick={prevStep} disabled={currentStep === 0}>\n          Previous\n        </Button>\n        {currentStep < steps.length - 1 ? (\n          <Button onClick={nextStep}>Next</Button>\n        ) : (\n          <Button onClick={() => console.log('Submit', formData)}>Submit Referral</Button>\n        )}\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test each step of the wizard for validation\n2. Verify that the slot picker correctly displays available slots\n3. Test safety questions validation\n4. Ensure the simulated AI recommendation component displays correctly and uses only mock data\n5. Validate form submission and error handling\n6. Test the entire flow end-to-end\n7. Verify that all AI functionality works completely offline with no external API calls\n8. Test that AI slot suggestions and center recommendations follow deterministic rules based on input data",
        "subtasks": [
          {
            "id": 1,
            "title": "Create mock data structure for simulated AI recommendations",
            "description": "Design and implement a mock data structure that will be used for simulating AI recommendations in the referral wizard. This should include rules for center suggestions based on exam type, patient location, and other factors.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement rule-based slot suggestion algorithm",
            "description": "Create a deterministic algorithm that suggests appointment slots based on predefined rules like proximity to patient address, availability, and exam type compatibility. This should work entirely offline with mock data.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build AIRecommendation component with simulated intelligence",
            "description": "Implement the AIRecommendation component that displays in the right rail, showing contextual suggestions based on the current wizard step and form data. All recommendations should be generated from local rules and mock data.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Attorney and Funder Dashboards",
        "description": "Implement the Attorney and Funder role-specific dashboards with case management, packet preview, and funding approval functionality. All AI functionality must be mocked/simulated for the demo app.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "details": "1. Create Attorney Dashboard with:\n   - KPI cards for active clients, attendance %, pending packets, lien exposure\n   - Case table with status and next action\n   - Packet preview component\n   - Simulated AI Suggestions for client management using predefined rules and mock data\n\n2. Create Funder Dashboard with:\n   - KPI cards for exposure, approvals pending, avg decision time, expected ROI\n   - Area chart for exposure over time\n   - Case table with approval status\n   - Simulated AI Suggestions for case approvals using deterministic, rule-based logic\n\n3. Implement the Case Packet preview component\n4. Create the Lien Ledger component with interest calculation\n\n5. AI Simulation Implementation:\n   - Use predefined rules based on mock data for all AI insights\n   - Implement deterministic and rule-based case recommendations\n   - Ensure no real AI APIs or services are required\n   - Design the simulation to provide a convincing AI experience while running completely offline\n\nExample Attorney Dashboard:\n```tsx\n// src/pages/AttorneyDashboard.tsx\nimport { useEffect, useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';\nimport { Badge } from '@/components/ui/badge';\nimport { AITip } from '@/components/AITip';\nimport { PacketPreview } from '@/components/PacketPreview';\nimport { useStore } from '@/store';\n\nexport function AttorneyDashboard() {\n  const [loading, setLoading] = useState(true);\n  const [selectedCase, setSelectedCase] = useState(null);\n  const { cases, fetchCases } = useStore();\n  \n  useEffect(() => {\n    fetchCases().finally(() => setLoading(false));\n  }, [fetchCases]);\n  \n  // Calculate KPIs\n  const activeClients = cases.length;\n  const attendanceRate = cases.reduce((acc, c) => acc + (c.attendanceRate || 0), 0) / cases.length;\n  const pendingPackets = cases.filter(c => c.packetStatus === 'pending').length;\n  const totalExposure = cases.reduce((acc, c) => acc + (c.lienAmount || 0), 0);\n  \n  return (\n    <>\n      <div className=\"col-span-12\">\n        <h1 className=\"text-3xl font-bold mb-6\">Attorney Dashboard</h1>\n      </div>\n      \n      {/* KPI Row */}\n      <div className=\"col-span-3\">\n        <Card>\n          <CardHeader className=\"pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Active Clients</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{activeClients}</div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      <div className=\"col-span-3\">\n        <Card>\n          <CardHeader className=\"pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Attendance %</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{Math.round(attendanceRate * 100)}%</div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      <div className=\"col-span-3\">\n        <Card>\n          <CardHeader className=\"pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Pending Packets</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{pendingPackets}</div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      <div className=\"col-span-3\">\n        <Card>\n          <CardHeader className=\"pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Lien Exposure</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">${totalExposure.toLocaleString()}</div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Case Table */}\n      <div className=\"col-span-12 lg:col-span-8\">\n        <Card>\n          <CardHeader>\n            <CardTitle>Active Cases</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <Table>\n              <TableHeader>\n                <TableRow>\n                  <TableHead>Client</TableHead>\n                  <TableHead>Status</TableHead>\n                  <TableHead>Next Action</TableHead>\n                  <TableHead>Lien Amount</TableHead>\n                  <TableHead></TableHead>\n                </TableRow>\n              </TableHeader>\n              <TableBody>\n                {loading ? (\n                  Array(5).fill(0).map((_, i) => (\n                    <TableRow key={i}>\n                      <TableCell colSpan={5}>\n                        <div className=\"h-8 animate-pulse bg-muted rounded\" />\n                      </TableCell>\n                    </TableRow>\n                  ))\n                ) : cases.map(c => (\n                  <TableRow key={c.id}>\n                    <TableCell>{c.clientName}</TableCell>\n                    <TableCell>\n                      <Badge variant={c.status === 'active' ? 'default' : c.status === 'pending' ? 'secondary' : 'outline'}>\n                        {c.status}\n                      </Badge>\n                    </TableCell>\n                    <TableCell>{c.nextAction}</TableCell>\n                    <TableCell>${c.lienAmount?.toLocaleString()}</TableCell>\n                    <TableCell>\n                      <Button size=\"sm\" onClick={() => setSelectedCase(c)}>View</Button>\n                    </TableCell>\n                  </TableRow>\n                ))}\n              </TableBody>\n            </Table>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* AI Tips and Packet Preview */}\n      <div className=\"col-span-12 lg:col-span-4\">\n        <AITip tip=\"Two clients are at risk of no-show this week. Consider sending reminders to John Doe and Jane Smith.\" />\n        \n        {selectedCase && (\n          <Card className=\"mt-6\">\n            <CardHeader>\n              <CardTitle>Case Packet Preview</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <PacketPreview caseId={selectedCase.id} />\n              <Button className=\"w-full mt-4\">Generate Full Packet</Button>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n    </>\n  );\n}\n```",
        "testStrategy": "1. Test both dashboards in all theme modes\n2. Verify that KPIs display correct data\n3. Test the Case Packet preview functionality\n4. Validate the Lien Ledger calculations\n5. Test responsive layout on different screen sizes\n6. Ensure simulated AI Suggestions display correctly and use only mock data\n7. Verify that all AI functionality works completely offline\n8. Test that AI recommendations are deterministic and rule-based\n9. Validate that the simulated AI provides a convincing experience without requiring external services",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Attorney Dashboard UI components",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Funder Dashboard UI components",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Case Packet preview component",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Lien Ledger component with interest calculation",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement rule-based AI simulation for Attorney Dashboard",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement rule-based AI simulation for Funder Dashboard",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create mock data structures for AI recommendations",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Test all AI simulations in offline mode",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Ops Dashboard and Center Scorecards",
        "description": "Implement the Ops Dashboard with queues, center scorecards, and reassignment functionality.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "details": "1. Create Ops Dashboard with:\n   - Queue cards for Missing docs, No-shows, Aged referrals\n   - Center SLA scorecards with badges\n   - AI Suggestions for optimization (using mock data and rule-based logic)\n\n2. Implement queue filtering and bulk actions\n3. Create the center reassignment flow\n4. Add audit logging for actions\n5. Mock all AI functionality:\n   - Use predefined rules based on mock data for recommendations\n   - Implement deterministic, rule-based AI workflow suggestions\n   - No real AI APIs or services should be required\n   - Simulate intelligent behavior using existing mock data structures\n\nExample Ops Dashboard:\n```tsx\n// src/pages/OpsDashboard.tsx\nimport { useEffect, useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Button } from '@/components/ui/button';\nimport { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';\nimport { Badge } from '@/components/ui/badge';\nimport { AITip } from '@/components/AITip';\nimport { CenterScorecard } from '@/components/CenterScorecard';\nimport { useStore } from '@/store';\n\nexport function OpsDashboard() {\n  const [loading, setLoading] = useState(true);\n  const { queues, centers, fetchQueues, fetchCenters } = useStore();\n  \n  useEffect(() => {\n    Promise.all([\n      fetchQueues(),\n      fetchCenters()\n    ]).finally(() => setLoading(false));\n  }, [fetchQueues, fetchCenters]);\n  \n  return (\n    <>\n      <div className=\"col-span-12\">\n        <h1 className=\"text-3xl font-bold mb-6\">Operations Dashboard</h1>\n      </div>\n      \n      {/* Queues */}\n      <div className=\"col-span-12\">\n        <Card>\n          <CardHeader>\n            <CardTitle>Action Queues</CardTitle>\n            <CardDescription>Items requiring attention</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <Tabs defaultValue=\"missing-docs\">\n              <TabsList className=\"mb-4\">\n                <TabsTrigger value=\"missing-docs\">\n                  Missing Docs\n                  <Badge className=\"ml-2\" variant=\"secondary\">{queues.missingDocs?.length || 0}</Badge>\n                </TabsTrigger>\n                <TabsTrigger value=\"no-shows\">\n                  No-Shows\n                  <Badge className=\"ml-2\" variant=\"secondary\">{queues.noShows?.length || 0}</Badge>\n                </TabsTrigger>\n                <TabsTrigger value=\"aged-referrals\">\n                  Aged Referrals\n                  <Badge className=\"ml-2\" variant=\"secondary\">{queues.agedReferrals?.length || 0}</Badge>\n                </TabsTrigger>\n              </TabsList>\n              \n              <TabsContent value=\"missing-docs\">\n                <Table>\n                  <TableHeader>\n                    <TableRow>\n                      <TableHead>Patient</TableHead>\n                      <TableHead>Referrer</TableHead>\n                      <TableHead>Missing Document</TableHead>\n                      <TableHead>Age (days)</TableHead>\n                      <TableHead></TableHead>\n                    </TableRow>\n                  </TableHeader>\n                  <TableBody>\n                    {loading ? (\n                      Array(5).fill(0).map((_, i) => (\n                        <TableRow key={i}>\n                          <TableCell colSpan={5}>\n                            <div className=\"h-8 animate-pulse bg-muted rounded\" />\n                          </TableCell>\n                        </TableRow>\n                      ))\n                    ) : queues.missingDocs?.map(item => (\n                      <TableRow key={item.id}>\n                        <TableCell>{item.patientName}</TableCell>\n                        <TableCell>{item.referrerName}</TableCell>\n                        <TableCell>{item.missingDoc}</TableCell>\n                        <TableCell>{item.ageDays}</TableCell>\n                        <TableCell>\n                          <Button size=\"sm\">Request</Button>\n                        </TableCell>\n                      </TableRow>\n                    ))}\n                  </TableBody>\n                </Table>\n              </TabsContent>\n              \n              {/* Similar tables for other tabs */}\n            </Tabs>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Center Scorecards */}\n      <div className=\"col-span-12 mt-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Center Scorecards</h2>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {loading ? (\n            Array(3).fill(0).map((_, i) => (\n              <div key={i} className=\"h-64 animate-pulse bg-muted rounded\" />\n            ))\n          ) : centers.map(center => (\n            <CenterScorecard key={center.id} center={center} />\n          ))}\n        </div>\n      </div>\n      \n      {/* AI Suggestions */}\n      <div className=\"col-span-12 mt-6\">\n        <AITip tip=\"Consider reassigning John Doe's MRI to Center B which has availability tomorrow. Center A is currently booking 7+ days out.\" />\n      </div>\n    </>\n  );\n}\n```",
        "testStrategy": "1. Test the dashboard in all theme modes\n2. Verify that queues display correct data and filter properly\n3. Test the center reassignment flow\n4. Validate that scorecards display correct metrics\n5. Test responsive layout on different screen sizes\n6. Ensure AI Suggestions display correctly using mock data\n7. Verify audit logging for actions\n8. Test that AI recommendations are deterministic and rule-based\n9. Confirm the app runs completely offline with simulated AI functionality",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Admin Dashboard and Master Data",
        "description": "Implement the Admin Dashboard with theme management and master data display.",
        "details": "1. Create Admin Dashboard with:\n   - Theme Manager component\n   - Users/Roles static list\n\n2. Implement the Theme Manager with preset selection\n3. Create read-only views of master data entities\n\nExample Theme Manager:\n```tsx\n// src/components/ThemeManager.tsx\nimport { useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Label } from '@/components/ui/label';\nimport { Switch } from '@/components/ui/switch';\nimport { useTheme } from '@/hooks/useTheme';\n\nconst presets = [\n  { id: 'light', name: 'Light' },\n  { id: 'dark', name: 'Dark' },\n  { id: 'neon', name: 'MRI Neon' }\n];\n\nexport function ThemeManager() {\n  const { theme, setTheme, isDark, setIsDark } = useTheme();\n  \n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>Theme Manager</CardTitle>\n        <CardDescription>Customize the appearance of the platform</CardDescription>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-6\">\n          <div>\n            <h3 className=\"text-lg font-medium mb-2\">Color Preset</h3>\n            <RadioGroup value={theme} onValueChange={setTheme}>\n              {presets.map(preset => (\n                <div key={preset.id} className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value={preset.id} id={`preset-${preset.id}`} />\n                  <Label htmlFor={`preset-${preset.id}`}>{preset.name}</Label>\n                </div>\n              ))}\n            </RadioGroup>\n          </div>\n          \n          <div className=\"flex items-center space-x-2\">\n            <Switch id=\"dark-mode\" checked={isDark} onCheckedChange={setIsDark} />\n            <Label htmlFor=\"dark-mode\">Dark Mode</Label>\n          </div>\n          \n          <div className=\"grid grid-cols-2 gap-4 mt-6\">\n            <div className=\"p-4 rounded bg-background border border-border\">\n              <span className=\"text-foreground\">Background</span>\n            </div>\n            <div className=\"p-4 rounded bg-primary text-primary-foreground\">\n              <span>Primary</span>\n            </div>\n            <div className=\"p-4 rounded bg-secondary text-secondary-foreground\">\n              <span>Secondary</span>\n            </div>\n            <div className=\"p-4 rounded bg-muted text-muted-foreground\">\n              <span>Muted</span>\n            </div>\n            <div className=\"p-4 rounded bg-accent text-accent-foreground\">\n              <span>Accent</span>\n            </div>\n            <div className=\"p-4 rounded bg-destructive text-destructive-foreground\">\n              <span>Destructive</span>\n            </div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Test the Theme Manager in all theme modes\n2. Verify that theme presets apply correctly\n3. Test dark mode toggle\n4. Validate that master data displays correctly\n5. Test responsive layout on different screen sizes",
        "priority": "low",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "AI Insight Drawer Implementation",
        "description": "Implement the AI Insight Drawer component with context-aware suggestions based on heuristics over seed data. ALL AI functionality must be mocked/simulated for the demo app.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "details": "1. Create the AI Insight Drawer component that can be toggled open/closed\n2. Implement heuristic functions to generate suggestions based on the current page and user role\n3. Create an MSW handler for `/ai/suggest` to simulate AI responses\n4. Add different suggestion styles (clinical, friendly, concise)\n5. ALL AI insights must use predefined rules based on mock data\n6. ALL AI suggestions must be deterministic and rule-based\n7. NO real AI APIs or services should be required\n8. The goal is to simulate intelligent behavior using existing mock data structures\n\nExample AI Insight Drawer:\n```tsx\n// src/components/AIDrawer.tsx\nimport { useEffect, useState } from 'react';\nimport { X } from 'lucide-react';\nimport { Button } from './ui/button';\nimport { Skeleton } from './ui/skeleton';\nimport { useLocation } from 'react-router-dom';\nimport { useStore } from '@/store';\n\nexport function AIDrawer({ onClose }) {\n  const [loading, setLoading] = useState(true);\n  const [suggestions, setSuggestions] = useState([]);\n  const location = useLocation();\n  const { currentUser } = useStore();\n  \n  useEffect(() => {\n    // Fetch AI suggestions based on current page and role\n    fetch(`/api/ai/suggest?path=${location.pathname}&role=${currentUser.role}`)\n      .then(res => res.json())\n      .then(data => {\n        setSuggestions(data.suggestions);\n        setLoading(false);\n      });\n  }, [location.pathname, currentUser.role]);\n  \n  return (\n    <div className=\"w-80 border-l border-border bg-background p-4 flex flex-col h-full\">\n      <div className=\"flex justify-between items-center mb-4\">\n        <h2 className=\"text-lg font-bold\">AI Insights</h2>\n        <Button variant=\"ghost\" size=\"icon\" onClick={onClose}>\n          <X className=\"h-4 w-4\" />\n        </Button>\n      </div>\n      \n      <div className=\"flex-1 overflow-y-auto space-y-4\">\n        {loading ? (\n          Array(3).fill(0).map((_, i) => (\n            <div key={i} className=\"p-4 border border-border rounded-lg\">\n              <Skeleton className=\"h-4 w-3/4 mb-2\" />\n              <Skeleton className=\"h-4 w-full mb-2\" />\n              <Skeleton className=\"h-4 w-5/6\" />\n            </div>\n          ))\n        ) : suggestions.map((suggestion, i) => (\n          <div key={i} className=\"p-4 border border-border rounded-lg\">\n            <h3 className=\"font-medium mb-1\">{suggestion.title}</h3>\n            <p className=\"text-sm text-muted-foreground\">{suggestion.description}</p>\n            {suggestion.action && (\n              <Button variant=\"link\" className=\"p-0 h-auto mt-2 text-sm\">\n                {suggestion.action}\n              </Button>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\nExample MSW handler:\n```tsx\n// src/mocks/handlers.ts (addition)\nrest.get('/api/ai/suggest', (req, res, ctx) => {\n  const path = req.url.searchParams.get('path');\n  const role = req.url.searchParams.get('role');\n  \n  // Generate suggestions based on path and role\n  let suggestions = [];\n  \n  if (path.includes('/referrer') && role === 'referrer') {\n    suggestions = [\n      {\n        title: 'Center Recommendation',\n        description: 'Based on recent turnaround times, Center A is currently processing MRIs 2 days faster than average.',\n        action: 'View Center Details'\n      },\n      {\n        title: 'Patient Follow-up',\n        description: 'Three patients have completed scans in the last week with reports now available.',\n        action: 'View Reports'\n      }\n    ];\n  } else if (path.includes('/attorney') && role === 'attorney') {\n    suggestions = [\n      {\n        title: 'No-show Risk',\n        description: 'Two clients are at risk of no-show this week. Consider sending reminders to John Doe and Jane Smith.',\n        action: 'Send Reminders'\n      },\n      {\n        title: 'Missing Documentation',\n        description: 'Case #12345 is missing insurance verification which may delay processing.',\n        action: 'Request Document'\n      }\n    ];\n  }\n  // Add more conditions for other paths/roles\n  \n  return res(\n    ctx.delay(300 + Math.random() * 400),\n    ctx.status(200),\n    ctx.json({ suggestions })\n  );\n});\n```",
        "testStrategy": "1. Test the AI Drawer in all theme modes\n2. Verify that suggestions change based on current page and role\n3. Test loading states and error handling\n4. Validate that the drawer can be toggled open/closed\n5. Test responsive layout on different screen sizes\n6. Verify that all AI suggestions are deterministic and based on mock data\n7. Confirm that the system works completely offline without any external AI service dependencies\n8. Test that different suggestion styles (clinical, friendly, concise) render correctly",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AI Insight Drawer component with toggle functionality",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement rule-based heuristic functions for generating context-aware suggestions",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create MSW handler for simulating AI responses",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement different suggestion styles (clinical, friendly, concise)",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create deterministic rules for suggestions based on existing mock data",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Ensure all AI functionality works offline without external dependencies",
            "description": "",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Case Packet and Lien Ledger Components",
        "description": "Implement the Case Packet preview and Lien Ledger components for the Attorney workspace.",
        "details": "1. Create the Case Packet preview component that compiles:\n   - Records\n   - Bills\n   - Images placeholder\n   - Radiology report\n\n2. Implement the Lien Ledger component with:\n   - Interest calculation\n   - Adjustments\n   - Settlement disbursement splits\n\n3. Add PDF export functionality (simulated)\n\nExample Case Packet Preview:\n```tsx\n// src/components/PacketPreview.tsx\nimport { useEffect, useState } from 'react';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Button } from '@/components/ui/button';\nimport { FileText, Image, DollarSign, FileCheck } from 'lucide-react';\nimport { useStore } from '@/store';\n\ninterface PacketPreviewProps {\n  caseId: string;\n}\n\nexport function PacketPreview({ caseId }: PacketPreviewProps) {\n  const [loading, setLoading] = useState(true);\n  const [packetData, setPacketData] = useState(null);\n  const { fetchCasePacket } = useStore();\n  \n  useEffect(() => {\n    fetchCasePacket(caseId)\n      .then(data => {\n        setPacketData(data);\n        setLoading(false);\n      });\n  }, [caseId, fetchCasePacket]);\n  \n  if (loading) {\n    return (\n      <div className=\"h-64 animate-pulse bg-muted rounded\" />\n    );\n  }\n  \n  return (\n    <div>\n      <Tabs defaultValue=\"records\">\n        <TabsList className=\"mb-4\">\n          <TabsTrigger value=\"records\">\n            <FileText className=\"h-4 w-4 mr-2\" />\n            Records\n          </TabsTrigger>\n          <TabsTrigger value=\"bills\">\n            <DollarSign className=\"h-4 w-4 mr-2\" />\n            Bills\n          </TabsTrigger>\n          <TabsTrigger value=\"images\">\n            <Image className=\"h-4 w-4 mr-2\" />\n            Images\n          </TabsTrigger>\n          <TabsTrigger value=\"report\">\n            <FileCheck className=\"h-4 w-4 mr-2\" />\n            Report\n          </TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"records\">\n          <Card>\n            <CardContent className=\"p-4\">\n              <div className=\"space-y-2\">\n                {packetData.records.map(record => (\n                  <div key={record.id} className=\"flex justify-between items-center p-2 border-b border-border\">\n                    <div>\n                      <div className=\"font-medium\">{record.title}</div>\n                      <div className=\"text-sm text-muted-foreground\">{record.date}</div>\n                    </div>\n                    <Button variant=\"ghost\" size=\"sm\">View</Button>\n                  </div>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n        \n        <TabsContent value=\"bills\">\n          <Card>\n            <CardContent className=\"p-4\">\n              <div className=\"space-y-2\">\n                {packetData.bills.map(bill => (\n                  <div key={bill.id} className=\"flex justify-between items-center p-2 border-b border-border\">\n                    <div>\n                      <div className=\"font-medium\">{bill.provider}</div>\n                      <div className=\"text-sm text-muted-foreground\">${bill.amount.toLocaleString()} - {bill.date}</div>\n                    </div>\n                    <Button variant=\"ghost\" size=\"sm\">View</Button>\n                  </div>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n        \n        {/* Similar content for other tabs */}\n      </Tabs>\n    </div>\n  );\n}\n```\n\nExample Lien Ledger:\n```tsx\n// src/components/LienLedger.tsx\nimport { useState } from 'react';\nimport { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Plus } from 'lucide-react';\n\ninterface LienLedgerProps {\n  lien: {\n    id: string;\n    principal: number;\n    rateApr: number;\n    accrualBasis: string;\n    ledger: Array<{\n      date: string;\n      description: string;\n      amount: number;\n      balance: number;\n    }>;\n  };\n  onUpdate: (ledger: any) => void;\n}\n\nexport function LienLedger({ lien, onUpdate }: LienLedgerProps) {\n  const [newEntry, setNewEntry] = useState({\n    date: new Date().toISOString().split('T')[0],\n    description: '',\n    amount: 0\n  });\n  \n  const calculateInterest = (principal, rateApr, days) => {\n    const dailyRate = rateApr / 365;\n    return principal * dailyRate * days / 100;\n  };\n  \n  const addEntry = () => {\n    const lastEntry = lien.ledger[lien.ledger.length - 1];\n    const newBalance = lastEntry.balance + newEntry.amount;\n    \n    const updatedLedger = [\n      ...lien.ledger,\n      {\n        ...newEntry,\n        balance: newBalance\n      }\n    ];\n    \n    onUpdate({\n      ...lien,\n      ledger: updatedLedger\n    });\n    \n    setNewEntry({\n      date: new Date().toISOString().split('T')[0],\n      description: '',\n      amount: 0\n    });\n  };\n  \n  return (\n    <div>\n      <div className=\"mb-4\">\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div>\n            <p className=\"text-sm font-medium mb-1\">Principal</p>\n            <p className=\"text-lg font-bold\">${lien.principal.toLocaleString()}</p>\n          </div>\n          <div>\n            <p className=\"text-sm font-medium mb-1\">Rate (APR)</p>\n            <p className=\"text-lg font-bold\">{lien.rateApr}%</p>\n          </div>\n          <div>\n            <p className=\"text-sm font-medium mb-1\">Accrual Basis</p>\n            <p className=\"text-lg font-bold\">{lien.accrualBasis}</p>\n          </div>\n          <div>\n            <p className=\"text-sm font-medium mb-1\">Current Balance</p>\n            <p className=\"text-lg font-bold\">\n              ${lien.ledger[lien.ledger.length - 1].balance.toLocaleString()}\n            </p>\n          </div>\n        </div>\n      </div>\n      \n      <Table>\n        <TableHeader>\n          <TableRow>\n            <TableHead>Date</TableHead>\n            <TableHead>Description</TableHead>\n            <TableHead>Amount</TableHead>\n            <TableHead>Balance</TableHead>\n          </TableRow>\n        </TableHeader>\n        <TableBody>\n          {lien.ledger.map((entry, i) => (\n            <TableRow key={i}>\n              <TableCell>{entry.date}</TableCell>\n              <TableCell>{entry.description}</TableCell>\n              <TableCell>${entry.amount.toLocaleString()}</TableCell>\n              <TableCell>${entry.balance.toLocaleString()}</TableCell>\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n      \n      <div className=\"mt-4 grid grid-cols-12 gap-4 items-end\">\n        <div className=\"col-span-3\">\n          <label className=\"text-sm font-medium mb-1 block\">Date</label>\n          <Input\n            type=\"date\"\n            value={newEntry.date}\n            onChange={e => setNewEntry({ ...newEntry, date: e.target.value })}\n          />\n        </div>\n        <div className=\"col-span-5\">\n          <label className=\"text-sm font-medium mb-1 block\">Description</label>\n          <Input\n            value={newEntry.description}\n            onChange={e => setNewEntry({ ...newEntry, description: e.target.value })}\n            placeholder=\"Interest accrual, adjustment, etc.\"\n          />\n        </div>\n        <div className=\"col-span-3\">\n          <label className=\"text-sm font-medium mb-1 block\">Amount</label>\n          <Input\n            type=\"number\"\n            value={newEntry.amount}\n            onChange={e => setNewEntry({ ...newEntry, amount: parseFloat(e.target.value) || 0 })}\n          />\n        </div>\n        <div className=\"col-span-1\">\n          <Button onClick={addEntry}>\n            <Plus className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test the Case Packet preview in all theme modes\n2. Verify that packet documents display correctly\n3. Test the Lien Ledger calculations\n4. Validate that new entries can be added to the ledger\n5. Test PDF export functionality\n6. Test responsive layout on different screen sizes",
        "priority": "medium",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Charts and Data Visualization",
        "description": "Implement responsive charts using Nivo with theme-aware styling for various dashboards.",
        "details": "1. Create the following chart components:\n   - Center Utilization (calendar heatmap)\n   - Turnaround Time (line chart by center)\n   - No-Show Rate (stacked bar chart by cause)\n   - Funding Exposure (area chart over time)\n\n2. Implement theme-aware styling using CSS variables\n3. Ensure charts are responsive and accessible\n\nExample Chart Implementation:\n```tsx\n// src/components/charts/TurnaroundTimeChart.tsx\nimport { ResponsiveLine } from '@nivo/line';\nimport { useTheme } from '@/hooks/useTheme';\n\ninterface TurnaroundTimeChartProps {\n  data: Array<{\n    id: string;\n    data: Array<{\n      x: string; // date\n      y: number; // days\n    }>;\n  }>;\n}\n\nexport function TurnaroundTimeChart({ data }: TurnaroundTimeChartProps) {\n  const { isDark } = useTheme();\n  \n  return (\n    <div className=\"h-80\">\n      <ResponsiveLine\n        data={data}\n        margin={{ top: 20, right: 110, bottom: 50, left: 60 }}\n        xScale={{ type: 'point' }}\n        yScale={{ \n          type: 'linear', \n          min: 'auto', \n          max: 'auto', \n          stacked: false, \n          reverse: false \n        }}\n        axisTop={null}\n        axisRight={null}\n        axisBottom={{\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: 0,\n          legend: 'Date',\n          legendOffset: 36,\n          legendPosition: 'middle'\n        }}\n        axisLeft={{\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: 0,\n          legend: 'Turnaround Time (days)',\n          legendOffset: -40,\n          legendPosition: 'middle'\n        }}\n        colors={[\n          'var(--chart-1)',\n          'var(--chart-2)',\n          'var(--chart-3)',\n          'var(--chart-4)',\n          'var(--chart-5)'\n        ]}\n        pointSize={10}\n        pointColor={{ theme: 'background' }}\n        pointBorderWidth={2}\n        pointBorderColor={{ from: 'serieColor' }}\n        pointLabelYOffset={-12}\n        useMesh={true}\n        legends={[{\n          anchor: 'bottom-right',\n          direction: 'column',\n          justify: false,\n          translateX: 100,\n          translateY: 0,\n          itemsSpacing: 0,\n          itemDirection: 'left-to-right',\n          itemWidth: 80,\n          itemHeight: 20,\n          itemOpacity: 0.75,\n          symbolSize: 12,\n          symbolShape: 'circle',\n          symbolBorderColor: 'rgba(0, 0, 0, .5)',\n          effects: [{\n            on: 'hover',\n            style: {\n              itemBackground: 'rgba(0, 0, 0, .03)',\n              itemOpacity: 1\n            }\n          }]\n        }]}\n        theme={{\n          textColor: 'var(--foreground)',\n          fontSize: 11,\n          axis: {\n            domain: {\n              line: {\n                stroke: 'var(--border)',\n                strokeWidth: 1\n              }\n            },\n            ticks: {\n              line: {\n                stroke: 'var(--border)',\n                strokeWidth: 1\n              }\n            }\n          },\n          grid: {\n            line: {\n              stroke: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',\n              strokeWidth: 1\n            }\n          },\n          tooltip: {\n            container: {\n              background: 'var(--background)',\n              color: 'var(--foreground)',\n              fontSize: 12,\n              borderRadius: 'var(--radius)',\n              boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'\n            }\n          }\n        }}\n      />\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test all charts in both light and dark modes\n2. Verify that charts use the correct CSS variables for colors\n3. Test responsive behavior on different screen sizes\n4. Validate that tooltips display correctly\n5. Test accessibility features (keyboard navigation, screen reader support)\n6. Verify that charts update correctly when data changes",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Command-K Modal and Global Search",
        "description": "Implement the Command-K modal for quick actions and global search functionality.",
        "details": "1. Create a Command-K modal component that opens with the keyboard shortcut\n2. Implement global search functionality across entities\n3. Add quick action shortcuts for common tasks\n4. Ensure keyboard navigation works correctly\n\nExample Command-K Modal:\n```tsx\n// src/components/CommandK.tsx\nimport { useEffect, useState } from 'react';\nimport { Command } from 'cmdk';\nimport { Dialog, DialogContent } from './ui/dialog';\nimport { Search, Calendar, User, FileText, Settings, ChevronRight } from 'lucide-react';\nimport { useNavigate } from 'react-router-dom';\nimport { useStore } from '@/store';\n\nexport function CommandK() {\n  const [open, setOpen] = useState(false);\n  const navigate = useNavigate();\n  const { searchEntities } = useStore();\n  const [results, setResults] = useState([]);\n  const [query, setQuery] = useState('');\n  \n  useEffect(() => {\n    const down = (e) => {\n      if (e.key === 'k' && (e.metaKey || e.ctrlKey)) {\n        e.preventDefault();\n        setOpen(open => !open);\n      }\n    };\n    \n    document.addEventListener('keydown', down);\n    return () => document.removeEventListener('keydown', down);\n  }, []);\n  \n  useEffect(() => {\n    if (query.length > 1) {\n      searchEntities(query).then(setResults);\n    } else {\n      setResults([]);\n    }\n  }, [query, searchEntities]);\n  \n  const onSelect = (value) => {\n    setOpen(false);\n    \n    if (value.startsWith('/')) {\n      navigate(value);\n    } else if (value.startsWith('action:')) {\n      // Handle actions\n      const action = value.replace('action:', '');\n      if (action === 'new-referral') {\n        navigate('/referrer/new-referral');\n      } else if (action === 'theme') {\n        navigate('/admin/theme');\n      }\n    } else {\n      // Handle entity selection\n      const [type, id] = value.split(':');\n      if (type === 'patient') {\n        navigate(`/patients/${id}`);\n      } else if (type === 'referral') {\n        navigate(`/referrals/${id}`);\n      }\n    }\n  };\n  \n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogContent className=\"p-0 gap-0 max-w-2xl\">\n        <Command className=\"rounded-lg border shadow-md\">\n          <div className=\"flex items-center border-b px-3\">\n            <Search className=\"h-4 w-4 mr-2 text-muted-foreground\" />\n            <Command.Input \n              autoFocus \n              placeholder=\"Search or type a command...\"\n              className=\"flex-1 outline-none py-3\"\n              value={query}\n              onValueChange={setQuery}\n            />\n          </div>\n          <Command.List className=\"max-h-96 overflow-y-auto p-2\">\n            {query === '' ? (\n              <>\n                <Command.Group heading=\"Navigation\">\n                  <Command.Item onSelect={() => onSelect('/dashboard')}>\n                    <div className=\"flex items-center\">\n                      <Calendar className=\"h-4 w-4 mr-2\" />\n                      <span>Dashboard</span>\n                    </div>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground\" />\n                  </Command.Item>\n                  <Command.Item onSelect={() => onSelect('/referrals')}>\n                    <div className=\"flex items-center\">\n                      <FileText className=\"h-4 w-4 mr-2\" />\n                      <span>Referrals</span>\n                    </div>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground\" />\n                  </Command.Item>\n                  <Command.Item onSelect={() => onSelect('/admin/theme')}>\n                    <div className=\"flex items-center\">\n                      <Settings className=\"h-4 w-4 mr-2\" />\n                      <span>Theme Settings</span>\n                    </div>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground\" />\n                  </Command.Item>\n                </Command.Group>\n                \n                <Command.Group heading=\"Actions\">\n                  <Command.Item onSelect={() => onSelect('action:new-referral')}>\n                    <div className=\"flex items-center\">\n                      <FileText className=\"h-4 w-4 mr-2\" />\n                      <span>New Referral</span>\n                    </div>\n                  </Command.Item>\n                </Command.Group>\n              </>\n            ) : results.length > 0 ? (\n              <Command.Group heading=\"Results\">\n                {results.map(result => (\n                  <Command.Item\n                    key={`${result.type}:${result.id}`}\n                    onSelect={() => onSelect(`${result.type}:${result.id}`)}\n                  >\n                    <div className=\"flex items-center\">\n                      {result.type === 'patient' && <User className=\"h-4 w-4 mr-2\" />}\n                      {result.type === 'referral' && <FileText className=\"h-4 w-4 mr-2\" />}\n                      <span>{result.title}</span>\n                    </div>\n                    <span className=\"text-sm text-muted-foreground\">{result.subtitle}</span>\n                  </Command.Item>\n                ))}\n              </Command.Group>\n            ) : (\n              <Command.Empty>No results found.</Command.Empty>\n            )}\n          </Command.List>\n        </Command>\n      </DialogContent>\n    </Dialog>\n  );\n}\n```",
        "testStrategy": "1. Test that Command-K shortcut opens the modal\n2. Verify that search returns appropriate results\n3. Test keyboard navigation within the modal\n4. Validate that selecting items navigates to the correct page\n5. Test in all theme modes\n6. Ensure accessibility for keyboard-only users",
        "priority": "low",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Animations and Micro-interactions",
        "description": "Implement Framer Motion animations for page transitions, list item hover/press states, and modal entrances.",
        "details": "1. Add Framer Motion to the project\n2. Implement page transitions (≤200ms)\n3. Add hover/press animations for list items\n4. Create entrance animations for modals and drawers\n5. Respect `prefers-reduced-motion` preference\n\nExample Page Transition:\n```tsx\n// src/components/PageTransition.tsx\nimport { motion } from 'framer-motion';\nimport { useReducedMotion } from '@/hooks/useReducedMotion';\n\ninterface PageTransitionProps {\n  children: React.ReactNode;\n}\n\nexport function PageTransition({ children }: PageTransitionProps) {\n  const prefersReducedMotion = useReducedMotion();\n  \n  const variants = {\n    initial: { opacity: 0, y: prefersReducedMotion ? 0 : 10 },\n    animate: { opacity: 1, y: 0 },\n    exit: { opacity: 0, y: prefersReducedMotion ? 0 : -10 }\n  };\n  \n  return (\n    <motion.div\n      variants={variants}\n      initial=\"initial\"\n      animate=\"animate\"\n      exit=\"exit\"\n      transition={{ duration: prefersReducedMotion ? 0 : 0.2 }}\n    >\n      {children}\n    </motion.div>\n  );\n}\n```\n\nExample List Item Animation:\n```tsx\n// src/components/AnimatedListItem.tsx\nimport { motion } from 'framer-motion';\nimport { useReducedMotion } from '@/hooks/useReducedMotion';\n\ninterface AnimatedListItemProps {\n  children: React.ReactNode;\n  index: number;\n}\n\nexport function AnimatedListItem({ children, index }: AnimatedListItemProps) {\n  const prefersReducedMotion = useReducedMotion();\n  \n  const variants = {\n    initial: { opacity: 0, y: prefersReducedMotion ? 0 : 20 },\n    animate: { opacity: 1, y: 0 },\n    hover: { scale: prefersReducedMotion ? 1 : 1.02 }\n  };\n  \n  return (\n    <motion.div\n      variants={variants}\n      initial=\"initial\"\n      animate=\"animate\"\n      whileHover=\"hover\"\n      transition={{ \n        duration: prefersReducedMotion ? 0 : 0.2,\n        delay: prefersReducedMotion ? 0 : index * 0.05 \n      }}\n    >\n      {children}\n    </motion.div>\n  );\n}\n```\n\nExample Modal Animation:\n```tsx\n// src/components/ui/dialog.tsx (modified)\nimport * as React from 'react';\nimport * as DialogPrimitive from '@radix-ui/react-dialog';\nimport { X } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { useReducedMotion } from '@/hooks/useReducedMotion';\n\n// ... other Dialog components\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => {\n  const prefersReducedMotion = useReducedMotion();\n  \n  return (\n    <DialogPrimitive.Portal>\n      <DialogPrimitive.Overlay\n        className=\"fixed inset-0 z-50 bg-background/80 backdrop-blur-sm\"\n        asChild\n      >\n        <motion.div\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          transition={{ duration: prefersReducedMotion ? 0 : 0.15 }}\n        />\n      </DialogPrimitive.Overlay>\n      <DialogPrimitive.Content\n        ref={ref}\n        className={cn(\n          \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 sm:rounded-lg\",\n          className\n        )}\n        asChild\n        {...props}\n      >\n        <motion.div\n          initial={{ opacity: 0, scale: prefersReducedMotion ? 1 : 0.95 }}\n          animate={{ opacity: 1, scale: 1 }}\n          exit={{ opacity: 0, scale: prefersReducedMotion ? 1 : 0.95 }}\n          transition={{ duration: prefersReducedMotion ? 0 : 0.2 }}\n        >\n          {children}\n          <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\">\n            <X className=\"h-4 w-4\" />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        </motion.div>\n      </DialogPrimitive.Content>\n    </DialogPrimitive.Portal>\n  );\n});\nDialogContent.displayName = DialogPrimitive.Content.displayName;\n\n// ... export components\n```",
        "testStrategy": "1. Test animations in all theme modes\n2. Verify that animations respect the `prefers-reduced-motion` preference\n3. Test page transitions between different routes\n4. Validate that list item animations work correctly\n5. Test modal entrance and exit animations\n6. Ensure animations don't interfere with accessibility",
        "priority": "low",
        "dependencies": [
          2,
          4,
          5,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Accessibility and Final Polish",
        "description": "Implement accessibility improvements, add empty states, skeleton loaders, and prepare the demo script.",
        "details": "1. Perform an accessibility audit and fix issues:\n   - Ensure proper contrast ratios\n   - Add focus indicators\n   - Implement keyboard navigation\n   - Add ARIA attributes where needed\n\n2. Create empty states for all data-dependent components\n3. Add skeleton loaders for loading states\n4. Create a demo script for the three golden flows\n5. Add a README with setup instructions and Cursor.ai prompts\n6. Implement a one-click seed reset function\n\nExample Empty State:\n```tsx\n// src/components/EmptyState.tsx\nimport { FileQuestion } from 'lucide-react';\nimport { Button } from './ui/button';\n\ninterface EmptyStateProps {\n  title: string;\n  description: string;\n  icon?: React.ReactNode;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n}\n\nexport function EmptyState({ title, description, icon, action }: EmptyStateProps) {\n  return (\n    <div className=\"flex flex-col items-center justify-center p-8 text-center\">\n      <div className=\"rounded-full bg-muted p-3 mb-4\">\n        {icon || <FileQuestion className=\"h-6 w-6 text-muted-foreground\" />}\n      </div>\n      <h3 className=\"text-lg font-medium mb-1\">{title}</h3>\n      <p className=\"text-sm text-muted-foreground mb-4 max-w-md\">{description}</p>\n      {action && (\n        <Button onClick={action.onClick}>{action.label}</Button>\n      )}\n    </div>\n  );\n}\n```\n\nExample Skeleton Loader:\n```tsx\n// src/components/SkeletonCard.tsx\nimport { Card, CardContent, CardHeader } from './ui/card';\nimport { Skeleton } from './ui/skeleton';\n\nexport function SkeletonCard() {\n  return (\n    <Card>\n      <CardHeader className=\"pb-2\">\n        <Skeleton className=\"h-5 w-1/3\" />\n      </CardHeader>\n      <CardContent>\n        <Skeleton className=\"h-8 w-1/2 mb-4\" />\n        <Skeleton className=\"h-4 w-full mb-2\" />\n        <Skeleton className=\"h-4 w-4/5 mb-2\" />\n        <Skeleton className=\"h-4 w-2/3\" />\n      </CardContent>\n    </Card>\n  );\n}\n```\n\nExample README section:\n```markdown\n## MRIGuys Platform Visual Prototype\n\nThis is a visual prototype for the MRIGuys Platform, a PI-friendly diagnostic imaging marketplace and workflow platform.\n\n### Setup\n\n1. Clone the repository\n2. Install dependencies: `pnpm install`\n3. Start the development server: `pnpm dev`\n4. Open http://localhost:5173 in your browser\n\n### Demo Scenarios\n\n1. **Referrer Flow:** Create referral → AI suggests best center → pick slot → status updates → mock report appears\n   - Navigate to Referrer Dashboard\n   - Click \"New Referral\"\n   - Fill out the form and proceed through the wizard\n   - Select a center and slot\n   - Return to dashboard to see status update\n\n2. **Center Flow:** See worklist → complete scan → upload report → KPIs/Charts update\n   - Navigate to Center Dashboard\n   - View the worklist\n   - Complete a scan\n   - Upload a report\n   - Observe KPIs and charts update\n\n3. **Attorney Flow:** Open case → AI flags missing doc → generate Case Packet → export PDF\n   - Navigate to Attorney Dashboard\n   - Select a case\n   - View AI suggestions about missing documents\n   - Generate a Case Packet\n   - Export as PDF\n\n### Reset Demo Data\n\nTo reset the demo data to its initial state, run: `pnpm demo:reset`\n\n### Cursor.ai Prompts\n\nHere are some useful Cursor.ai prompts for working with this codebase:\n\n- \"Create a new dashboard component for [role]\" - Generates a role-specific dashboard\n- \"Implement a [component] with shadcn/ui and Tailwind\" - Creates UI components\n- \"Add Framer Motion animations to [component]\" - Adds animations to components\n- \"Create a mock API handler for [endpoint]\" - Sets up MSW handlers\n```",
        "testStrategy": "1. Perform an accessibility audit using axe or similar tools\n2. Test keyboard navigation throughout the application\n3. Verify that all components have appropriate empty states\n4. Test skeleton loaders during data fetching\n5. Validate that the demo script works for all three golden flows\n6. Test the seed reset functionality\n7. Ensure the README contains all necessary information",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Public Finder Implementation with Map and List Views",
        "description": "Implement the Public Finder functionality with search filters, map and list views, center profile modal, and deep-linking capabilities for the public booking flow without authentication. All AI functionality must be mocked/simulated for the demo app.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "high",
        "details": "**IMPORTANT: All UI components must use shadcn/ui components with proper cn() utility styling for consistent theming and responsive design.**\n\n1. Create search filter components using shadcn/ui:\n   - Location input (City/ZIP) with autocomplete using Input component\n   - Body Part selector (dropdown with categories) using Select component\n   - Modality selector (multi-select checkboxes) using Checkbox components\n   - Optional date range picker using DateRangePicker component\n   - All components styled using cn() utility for consistent theming\n\n2. Implement search results views using shadcn/ui:\n   - List view with center cards using Card, CardHeader, CardContent components\n   - Map view placeholder with mock markers and controls\n   - Toggle between views with state persistence\n   - Implement pagination for list view using Pagination components\n\n3. Build Center Profile modal using shadcn/ui:\n   - Modal structure using Dialog, DialogContent, DialogHeader, DialogTitle\n   - Badge system for modalities, magnet strength, languages using Badge component\n   - ADA compliance indicators with proper accessibility\n   - Accreditations section with tooltips\n   - Hours of operation and contact information\n\n4. Create deep-linking functionality:\n   - Generate URLs with center ID and search parameters\n   - Implement handlers to pre-populate Referral Wizard\n   - Add routing to Slot Picker with center preselected\n\n5. Responsive design implementation using Tailwind CSS:\n   - Mobile-first approach with responsive breakpoints (sm, md, lg, xl)\n   - Collapsible filters on mobile using responsive utilities\n   - Map view adjustments for small screens\n   - Modal adaptations for different devices\n\n6. Integration with existing components:\n   - Connect to mock API endpoints for centers data\n   - Implement state management for search filters using Zustand\n   - Add loading states and error handling using Skeleton components\n\n7. Mock AI functionality implementation:\n   - Implement center recommendations using predefined rules and mock data\n   - Create deterministic and rule-based search suggestions\n   - Simulate intelligent filtering with simple heuristics\n   - Ensure all AI-like features can run completely offline\n   - Use existing mock data structures to power simulated AI features\n\n8. Navigation and User Access Implementation:\n   - Public access: Implement as standalone page at `/centers` accessible without login\n   - Logged-in access: Add entry point in sidebar navigation under \"Find Centers\" section\n   - Top navigation: Add quick access button in header with map icon for all users\n   - Dashboard integration: Add \"Find Center\" card on patient dashboard with direct link\n   - Mobile menu: Include in hamburger menu for responsive layouts\n\n9. User Journey Implementation:\n   - Public users: Landing page → Centers link in top nav → Public Finder\n   - Logged-in patients: Dashboard → Find Center card → Public Finder with preferences pre-filled\n   - Logged-in providers: Sidebar → Find Centers → Public Finder with clinical filters pre-selected\n   - Referral flow integration: \"Find Center\" button in referral creation process → Public Finder with referral context\n\n10. Integration Points Implementation:\n    - Connect to upcoming appointment booking flow via \"Book Now\" buttons on center profiles\n    - Implement handoff to Referral Wizard with center selection preserved\n    - Add integration with user preferences system to save favorite centers\n    - Create connection points to upcoming features (center reviews, favorite lists)\n    - Implement state persistence between navigation events\n\n**Required shadcn/ui components:**\n- Input, Select, Checkbox, DateRangePicker for search filters\n- Card, CardHeader, CardContent for center cards\n- Dialog, DialogContent, DialogHeader, DialogTitle for modals\n- Badge for tags and indicators\n- Button for actions and navigation\n- Skeleton for loading states\n- Pagination for result navigation\n- Separator for visual divisions\n\n**Styling requirements:**\n- Use cn() utility function for all conditional class names\n- Implement responsive design with Tailwind CSS breakpoints\n- Ensure consistent theming across light/dark modes\n- Maintain accessibility standards with proper ARIA labels\n- Use existing color scheme and design tokens",
        "testStrategy": "1. Test search functionality:\n   - Verify that all filters (location, body part, modality, date range) work correctly\n   - Test autocomplete for location input\n   - Validate that search results update based on filter changes\n   - Test edge cases like no results found\n\n2. Test map view:\n   - Verify that markers appear in correct locations\n   - Test marker clustering for areas with many centers\n   - Validate that clicking a marker shows center information\n   - Test map controls (zoom, pan, etc.)\n   - Verify that map resizes properly on different screen sizes\n\n3. Test list view:\n   - Verify that center cards display all required information\n   - Test pagination functionality\n   - Validate sorting options\n   - Ensure responsive layout works on all screen sizes\n\n4. Test Center Profile modal:\n   - Verify that all center information displays correctly\n   - Test badge system for different center capabilities\n   - Validate that modal opens and closes properly\n   - Test responsive behavior on different screen sizes\n\n5. Test deep-linking:\n   - Verify that URLs with center ID correctly pre-populate forms\n   - Test deep links to Referral Wizard\n   - Validate deep links to Slot Picker\n   - Test handling of invalid parameters\n\n6. Test responsive design:\n   - Verify layout on mobile devices (320px width)\n   - Test tablet layout (768px width)\n   - Validate desktop layout (1024px+ width)\n   - Test filter collapse/expand on mobile\n   - Verify that map/list toggle works on all screen sizes\n\n7. Integration testing:\n   - Test with mock API responses\n   - Verify error handling for API failures\n   - Test loading states\n   - Validate that state is preserved when switching views\n\n8. Test mocked AI functionality:\n   - Verify that center recommendations use predefined rules and mock data only\n   - Test that search suggestions are deterministic and rule-based\n   - Confirm that all AI-like features work completely offline\n   - Validate that intelligent filtering uses simple heuristics as intended\n   - Test edge cases in the simulated AI behavior\n\n9. Test navigation and access patterns:\n   - Verify public access works without authentication at `/centers` route\n   - Test sidebar navigation item \"Find Centers\" for logged-in users\n   - Validate top navigation quick access button functionality\n   - Test dashboard integration with the \"Find Center\" card\n   - Verify mobile menu access in responsive layouts\n\n10. Test user journey flows:\n    - Validate the complete journey for public users from landing page\n    - Test logged-in patient journey from dashboard with preferences\n    - Verify provider journey with clinical filters pre-selection\n    - Test referral flow integration and context preservation\n    - Validate state persistence between navigation events\n\n11. Test integration points:\n    - Verify handoff to appointment booking flow works correctly\n    - Test Referral Wizard integration with center selection\n    - Validate user preferences system for saving favorite centers\n    - Test state persistence across different parts of the application",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement search filter components",
            "description": "Create search filter components using shadcn/ui components with proper cn() utility styling. Implement location input, body part selector, modality checkboxes, and date range picker.",
            "status": "done",
            "dependencies": [],
            "details": "✅ COMPLETED: Search filter components implemented using shadcn/ui components:\n- Location input with autocomplete using Input component\n- Body part selector dropdown using Select component\n- Modality multi-select checkboxes using Checkbox components\n- Date range picker using DateRangePicker component\n- All components styled using cn() utility for consistent theming\n- Responsive design with proper spacing and layout\n- Integration with Zustand store for data management",
            "testStrategy": "✅ COMPLETED: All search filter components tested and working:\n- Location input accepts city/ZIP input\n- Body part dropdown shows available options from mock data\n- Modality checkboxes allow multi-selection\n- Date range picker handles date selection\n- Search button triggers search with all filter values\n- Clear filters button resets all selections\n- Quick search buttons provide preset filter combinations"
          },
          {
            "id": 2,
            "title": "Create search results views (list and map)",
            "description": "Implement search results display using shadcn/ui components. Create list view with center cards and map view placeholder with proper responsive design.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement search results views using shadcn/ui components:\n- List view: Use Card, CardHeader, CardContent components for center cards\n- Center cards: Display center name, location, rating, modalities, features\n- Map view: Create placeholder component with mock markers and controls\n- Toggle between views: Implement view mode switching with state persistence\n- Responsive grid: Use CSS Grid for responsive card layout\n- Loading states: Implement Skeleton components for loading states\n- No results state: Create empty state with helpful messaging\n- Sorting options: Add sort dropdown for distance, rating, TAT\n- Pagination: Implement pagination controls for large result sets\n\nRequired shadcn/ui components:\n- Card, CardHeader, CardContent for center cards\n- Badge for modality and feature tags\n- Button for actions and view toggle\n- Skeleton for loading states\n- Select for sorting options\n- Pagination components for navigation\n<info added on 2025-08-26T09:54:03.499Z>\n**Implemented Features:**\n\n1. **Enhanced List View:**\n   - Center cards using Card, CardHeader, CardContent components with proper shadcn/ui styling\n   - Responsive grid layout (1 column on mobile, 2 on tablet, 3 on desktop)\n   - Center cards display: name, location, rating, TAT, modalities, features, contact info\n   - Action buttons for booking appointments and getting directions\n\n2. **Enhanced Map View:**\n   - Interactive placeholder with realistic mock marker distribution\n   - Hover effects with center information tooltips\n   - Map controls (zoom in/out, navigation, layers) with proper styling\n   - Enhanced legend with better visual hierarchy\n   - Responsive design for all screen sizes\n\n3. **Improved View Toggle:**\n   - Prominent toggle between list and map views\n   - Uses proper shadcn/ui styling with active state indicators\n   - View mode persistence in localStorage\n   - Smooth transitions and hover effects\n\n4. **Enhanced Sorting Controls:**\n   - Replaced HTML select with shadcn/ui Select component\n   - Sort by: Distance, Rating, Turnaround Time\n   - Proper styling and accessibility\n\n5. **Functional Pagination:**\n   - 12 items per page with proper pagination controls\n   - Page numbers with active state indicators\n   - Previous/Next buttons with proper disabled states\n   - Results summary showing current page range\n   - Auto-reset to page 1 when search results change\n   - Smooth scroll to top on page change\n\n6. **Responsive Design:**\n   - Mobile-first approach with proper breakpoints\n   - Responsive grid layouts and spacing\n   - Touch-friendly interactions\n   - Proper mobile navigation\n\n7. **State Management:**\n   - Local view mode state with persistence\n   - Pagination state management\n   - Search results filtering and sorting\n   - Modal state for center profiles\n\n**Technical Implementation:**\n- Used shadcn/ui components: Card, Button, Select, Skeleton, Badge\n- Implemented proper responsive design with Tailwind CSS\n- Added localStorage persistence for user preferences\n- Enhanced mock map view with realistic marker positioning\n- Improved accessibility with proper ARIA labels and keyboard navigation\n\n**Files Modified:**\n- src/components/public/SearchResults.jsx (enhanced with pagination, view toggle, sorting)\n- src/components/public/MapView.jsx (enhanced mock markers and controls)\n- src/components/ui/select.jsx (fixed import path)\n- src/pages/PublicFinder.jsx (removed duplicate view toggle)\n</info added on 2025-08-26T09:54:03.499Z>",
            "testStrategy": "Test search results functionality:\n- Verify list view displays center cards with all required information\n- Test map view placeholder renders correctly with mock markers\n- Validate view toggle functionality between list and map\n- Test responsive grid layout on different screen sizes\n- Verify loading states display correctly during search\n- Test empty state when no results found\n- Validate sorting functionality for different criteria\n- Test pagination controls for large result sets\n- Ensure all shadcn/ui components render correctly"
          },
          {
            "id": 3,
            "title": "Build Center Profile modal",
            "description": "Create comprehensive center profile modal using shadcn/ui Dialog components. Display detailed center information with proper styling and responsive design.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Build Center Profile modal using shadcn/ui components:\n- Modal structure: Use Dialog, DialogContent, DialogHeader, DialogTitle\n- Header section: Center name, address, rating with star display\n- Information sections: Modalities, features, accreditations, compliance\n- Performance metrics: TAT, utilization, no-show rate, satisfaction score\n- Contact information: Phone, email, website with proper formatting\n- Hours display: Operating hours with clear formatting\n- Action buttons: Book appointment, get directions, call center\n- Responsive design: Ensure modal works on all device sizes\n- Rich content: Display all center properties from enhanced mock data\n\nRequired shadcn/ui components:\n- Dialog, DialogContent, DialogHeader, DialogTitle for modal structure\n- Badge for modality, feature, and accreditation tags\n- Button for action buttons with proper variants\n- Separator for section divisions\n- Icons from lucide-react for visual elements\n- Responsive container with proper max-width and height\n\nEnhanced mock data requirements:\n- Ensure centers.json includes all required fields: avgTat, utilization, noShowRate, satisfactionScore, adaCompliant, languages, bodyParts\n- Add missing fields if not present in current mock data",
            "testStrategy": "Test Center Profile modal functionality:\n- Verify modal opens when center card is clicked\n- Test modal displays all center information correctly\n- Validate responsive behavior on different screen sizes\n- Test action button functionality (book, directions, call)\n- Verify badge system displays modalities and features correctly\n- Test performance metrics display with proper formatting\n- Validate contact information and hours display\n- Test modal close functionality\n- Ensure all shadcn/ui components render correctly\n- Verify enhanced mock data fields are displayed properly"
          },
          {
            "id": 4,
            "title": "Implement deep-linking functionality",
            "description": "Create deep-linking system for center selection and search parameters. Implement URL generation and parameter handling for seamless navigation.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement deep-linking functionality:\n- URL generation: Create URLs with center ID and search parameters\n- Parameter parsing: Handle URL parameters to pre-populate search filters\n- State persistence: Maintain search state across navigation\n- Referral integration: Generate deep links to Referral Wizard with center preselected\n- Slot picker routing: Add routing to Slot Picker with center context\n- Browser history: Implement proper browser history management\n- Share functionality: Enable sharing of specific center searches\n- Bookmark support: Allow bookmarking of filtered search results\n\nTechnical implementation:\n- Use React Router for URL parameter handling\n- Implement useSearchParams hook for query string management\n- Create utility functions for URL generation and parsing\n- Add useEffect hooks for parameter-based state updates\n- Implement fallback handling for invalid parameters\n- Add URL validation and sanitization\n\nIntegration points:\n- Connect to existing Referral Wizard routing\n- Integrate with Slot Picker component\n- Maintain search filter state in URL\n- Enable direct navigation to specific centers",
            "testStrategy": "Test deep-linking functionality:\n- Verify URL generation includes all search parameters\n- Test parameter parsing correctly updates search state\n- Validate deep links to Referral Wizard work properly\n- Test Slot Picker routing with center context\n- Verify browser history updates correctly\n- Test sharing functionality generates proper URLs\n- Validate bookmark support for filtered results\n- Test fallback handling for invalid parameters\n- Ensure state persistence across navigation\n- Verify integration with existing routing system"
          },
          {
            "id": 5,
            "title": "Develop responsive design adaptations",
            "description": "Implement comprehensive responsive design using Tailwind CSS and shadcn/ui components. Ensure optimal user experience across all device sizes.",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Develop responsive design adaptations:\n- Mobile-first approach: Design for 320px+ mobile devices first\n- Breakpoint system: Implement responsive breakpoints (sm, md, lg, xl)\n- Filter collapse: Make search filters collapsible on mobile\n- Map view adjustments: Optimize map view for small screens\n- Modal adaptations: Ensure modals work properly on all devices\n- Touch optimization: Implement touch-friendly interactions\n- Grid responsiveness: Use responsive CSS Grid for card layouts\n- Typography scaling: Implement responsive text sizing\n- Spacing adjustments: Use responsive spacing utilities\n- Navigation optimization: Ensure navigation works on all screen sizes\n\nTailwind CSS implementation:\n- Use responsive prefixes (sm:, md:, lg:, xl:) for breakpoint-specific styles\n- Implement responsive grid layouts with grid-cols-1 md:grid-cols-2 lg:grid-cols-3\n- Use responsive spacing with p-4 md:p-6 lg:p-8\n- Implement responsive typography with text-sm md:text-base lg:text-lg\n- Use responsive container sizing with max-w-sm md:max-w-md lg:max-w-lg\n\nshadcn/ui responsive features:\n- Ensure all components support responsive variants\n- Implement responsive dialog sizing\n- Use responsive button sizing\n- Implement responsive form layouts\n- Ensure proper responsive behavior for all UI components",
            "testStrategy": "Test responsive design functionality:\n- Verify mobile layout (320px width) displays correctly\n- Test tablet layout (768px width) functionality\n- Validate desktop layout (1024px+ width) appearance\n- Test filter collapse/expand on mobile devices\n- Verify map view adjustments for small screens\n- Test modal behavior on different device sizes\n- Validate touch interactions on mobile devices\n- Test grid responsiveness across breakpoints\n- Verify typography scaling on different screen sizes\n- Test spacing adjustments across breakpoints\n- Ensure all shadcn/ui components are responsive\n- Validate navigation functionality on all device sizes"
          },
          {
            "id": 6,
            "title": "Integrate with existing components and mock APIs",
            "description": "Integrate Public Finder with existing Zustand store, MSW mock APIs, and application components. Ensure seamless data flow and state management.",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Integrate with existing components and mock APIs:\n- Zustand store integration: Connect to centersSlice, bodyPartsSlice, and modalityOptions\n- MSW API integration: Use existing /api/centers, /api/body-parts endpoints\n- State management: Implement proper loading states and error handling\n- Data fetching: Use existing fetchCenters, fetchBodyParts functions\n- Component integration: Connect with existing Layout, Sidebar, TopMenu components\n- Navigation integration: Add to existing routing system\n- Theme integration: Ensure compatibility with existing theme system\n- Error handling: Use existing error handling patterns\n- Loading states: Implement consistent loading state management\n- Data persistence: Maintain search state across navigation\n\nRequired integrations:\n- Connect to existing MSW handlers for centers and body parts\n- Integrate with Zustand store for state management\n- Use existing theme context for consistent styling\n- Connect with existing navigation components\n- Implement existing error handling patterns\n- Use existing loading state management\n- Ensure compatibility with existing authentication system\n- Integrate with existing routing configuration",
            "testStrategy": "Test integration functionality:\n- Verify Zustand store integration works correctly\n- Test MSW API endpoints return proper data\n- Validate loading states display correctly\n- Test error handling for API failures\n- Verify state persistence across navigation\n- Test component integration with existing layout\n- Validate theme compatibility across components\n- Test navigation integration with existing system\n- Verify error handling follows existing patterns\n- Test loading state management consistency\n- Ensure compatibility with existing authentication\n- Validate routing integration works properly"
          },
          {
            "id": 7,
            "title": "Implement mocked AI center recommendations using predefined rules",
            "description": "Create simulated AI center recommendations using rule-based logic and existing mock data. Implement deterministic scoring algorithms for center suggestions.",
            "status": "pending",
            "dependencies": [
              6
            ],
            "details": "Implement mocked AI center recommendations:\n- Rule-based scoring: Create deterministic algorithms for center ranking\n- Distance weighting: Factor in geographic proximity to patient location\n- TAT optimization: Prioritize centers with better turnaround times\n- Rating consideration: Include center ratings in scoring algorithm\n- Modality matching: Prioritize centers with requested imaging types\n- Body part specialization: Consider center expertise in specific body areas\n- Availability scoring: Factor in slot availability and center utilization\n- Deterministic results: Ensure same inputs always produce same recommendations\n- Offline operation: All recommendations work without external AI services\n- Mock data integration: Use existing centers.json data for recommendations\n\nImplementation approach:\n- Create MockAIService class with recommendation methods\n- Implement scoring algorithm: (distance * 0.3) + (TAT * 0.4) + (rating * 0.3)\n- Use existing center properties: avgTat, rating, utilization, noShowRate\n- Generate mock reasoning for each recommendation\n- Ensure recommendations are context-aware and relevant\n- Implement caching for consistent results\n- Add confidence scores for each recommendation\n- Create fallback recommendations for edge cases",
            "testStrategy": "Test mocked AI recommendations:\n- Verify recommendations are deterministic and repeatable\n- Test scoring algorithm produces consistent results\n- Validate distance weighting affects recommendations\n- Test TAT optimization prioritizes faster centers\n- Verify rating consideration influences rankings\n- Test modality matching filters results correctly\n- Validate body part specialization consideration\n- Test availability scoring factors in center capacity\n- Ensure recommendations work without internet connectivity\n- Verify mock reasoning is convincing and relevant\n- Test fallback recommendations for edge cases\n- Validate confidence scores are reasonable and consistent"
          },
          {
            "id": 8,
            "title": "Create deterministic search suggestions based on mock data",
            "description": "Implement intelligent search suggestions using rule-based logic and existing mock data. Create context-aware search recommendations and autocomplete functionality.",
            "status": "pending",
            "dependencies": [
              7
            ],
            "details": "Create deterministic search suggestions:\n- Location autocomplete: Suggest cities and ZIP codes from existing center data\n- Modality suggestions: Recommend imaging types based on body part selection\n- Body part hints: Suggest relevant body parts for selected modalities\n- Search history: Implement mock search history for repeat searches\n- Popular searches: Create predefined popular search combinations\n- Context-aware suggestions: Adapt suggestions based on user selections\n- Deterministic behavior: Same inputs always produce same suggestions\n- Mock data integration: Use existing centers.json, bodyParts.json data\n- Offline functionality: All suggestions work without external services\n- Performance optimization: Implement efficient suggestion algorithms\n\nImplementation details:\n- Extract unique cities and ZIP codes from centers.json\n- Create modality-body part compatibility matrix\n- Implement search suggestion scoring algorithm\n- Add mock search history simulation\n- Create popular search templates\n- Implement suggestion filtering and ranking\n- Add suggestion caching for performance\n- Create fallback suggestions for edge cases\n- Implement suggestion validation\n- Add suggestion analytics tracking",
            "testStrategy": "Test search suggestions functionality:\n- Verify location autocomplete suggests valid cities/ZIPs\n- Test modality suggestions based on body part selection\n- Validate body part hints for selected modalities\n- Test search history displays correctly\n- Verify popular searches provide relevant combinations\n- Test context-aware suggestion adaptation\n- Validate deterministic behavior across sessions\n- Test offline functionality without internet connectivity\n- Verify suggestion performance and responsiveness\n- Test suggestion validation and error handling\n- Validate fallback suggestions for edge cases\n- Test suggestion analytics and tracking"
          },
          {
            "id": 9,
            "title": "Develop simple heuristics for intelligent filtering simulation",
            "description": "Implement intelligent filtering using rule-based heuristics and existing mock data. Create advanced filtering algorithms that simulate AI-powered search optimization.",
            "status": "pending",
            "dependencies": [
              8
            ],
            "details": "Develop intelligent filtering heuristics:\n- Smart ranking: Implement intelligent result ranking based on multiple factors\n- Relevance scoring: Score results based on search query relevance\n- Context awareness: Adapt filtering based on user behavior and preferences\n- Performance optimization: Use efficient algorithms for large datasets\n- Filter combination: Implement intelligent filter combination logic\n- Result clustering: Group similar results for better organization\n- Relevance feedback: Simulate learning from user interactions\n- Mock data integration: Use existing centers.json and related data\n- Offline operation: All filtering works without external services\n- Deterministic results: Same inputs always produce same filtered results\n\nHeuristic algorithms:\n- Relevance scoring: (query match * 0.4) + (location relevance * 0.3) + (specialty match * 0.3)\n- Smart ranking: Combine multiple factors with weighted scoring\n- Context filtering: Use user selections to refine other filter options\n- Result clustering: Group centers by geographic proximity and specialty\n- Performance optimization: Implement efficient search algorithms\n- Filter validation: Ensure filter combinations are logical and useful\n- Fallback logic: Provide sensible defaults for edge cases\n- Result caching: Cache filtered results for performance\n- Analytics tracking: Track filter usage and effectiveness",
            "testStrategy": "Test intelligent filtering functionality:\n- Verify smart ranking produces logical result order\n- Test relevance scoring accurately reflects search intent\n- Validate context awareness adapts filtering appropriately\n- Test performance with large datasets\n- Verify filter combination logic works correctly\n- Test result clustering groups similar results\n- Validate relevance feedback simulation\n- Test offline functionality without internet connectivity\n- Verify deterministic results across sessions\n- Test filter validation and error handling\n- Validate fallback logic for edge cases\n- Test result caching and performance optimization\n- Verify analytics tracking and reporting"
          },
          {
            "id": 10,
            "title": "Implement public access route at /centers",
            "description": "Create standalone page accessible without login at the /centers route. Implement proper routing and ensure the page works independently of the main application layout.",
            "status": "pending",
            "dependencies": [
              9
            ],
            "details": "Implement public access route at /centers:\n- Standalone routing: Create independent route that bypasses main Layout component\n- Public access: Ensure page is accessible without authentication\n- Responsive design: Implement mobile-first responsive design\n- SEO optimization: Add proper meta tags and page structure\n- Performance: Optimize loading and rendering performance\n- Accessibility: Ensure WCAG compliance and screen reader support\n- Error handling: Implement proper error boundaries and fallbacks\n- Loading states: Add loading indicators for better UX\n- Offline support: Ensure functionality works without internet connectivity\n- Browser compatibility: Support all modern browsers\n\nTechnical implementation:\n- Update App.jsx to add standalone /centers route\n- Create PublicFinder component with independent layout\n- Implement proper error boundaries\n- Add loading states and skeleton components\n- Ensure responsive design with Tailwind CSS\n- Implement proper meta tags and page titles\n- Add accessibility features and ARIA labels\n- Implement proper error handling\n- Add performance optimizations\n- Ensure offline functionality",
            "testStrategy": "Test public access route functionality:\n- Verify /centers route is accessible without authentication\n- Test standalone page loads independently of main layout\n- Validate responsive design on all device sizes\n- Test loading states and skeleton components\n- Verify error handling and fallbacks work correctly\n- Test accessibility features and screen reader support\n- Validate SEO meta tags and page structure\n- Test performance and loading optimization\n- Verify offline functionality without internet\n- Test browser compatibility across different browsers\n- Validate error boundaries and error states\n- Test responsive behavior on mobile devices"
          },
          {
            "id": 11,
            "title": "Add navigation entry points for different user roles",
            "description": "Implement comprehensive navigation integration for the Public Finder. Add entry points in sidebar, top navigation, and dashboard for seamless access across all user roles.",
            "status": "pending",
            "dependencies": [
              10
            ],
            "details": "Add navigation entry points for different user roles:\n- Sidebar navigation: Add \"Find Centers\" item in sidebar for logged-in users\n- Top navigation: Add quick access button in header with map icon\n- Dashboard integration: Add \"Find Center\" card on patient dashboard\n- Mobile menu: Include in hamburger menu for responsive layouts\n- Role-based access: Ensure appropriate access for different user types\n- Consistent styling: Use existing navigation patterns and styling\n- Icon integration: Add appropriate icons for navigation items\n- Active state: Implement proper active state for navigation items\n- Responsive behavior: Ensure navigation works on all device sizes\n- Accessibility: Add proper ARIA labels and keyboard navigation\n\nImplementation details:\n- Update Sidebar.jsx to add \"Find Centers\" navigation item\n- Update TopMenu.jsx to add quick access button\n- Update Dashboard.jsx to add \"Find Center\" card\n- Implement proper routing and navigation logic\n- Add appropriate icons from lucide-react\n- Ensure consistent styling with existing navigation\n- Implement responsive behavior for mobile devices\n- Add proper accessibility features\n- Ensure role-based access control\n- Implement proper active state management",
            "testStrategy": "Test navigation integration functionality:\n- Verify sidebar navigation item appears for logged-in users\n- Test top navigation quick access button functionality\n- Validate dashboard integration with \"Find Center\" card\n- Test mobile menu access in responsive layouts\n- Verify role-based access control works correctly\n- Test consistent styling with existing navigation\n- Validate icon integration and visual appearance\n- Test active state management for navigation items\n- Verify responsive behavior on all device sizes\n- Test accessibility features and keyboard navigation\n- Validate proper routing and navigation logic\n- Test mobile responsiveness and touch interactions"
          },
          {
            "id": 12,
            "title": "Implement user journey flows for different user types",
            "description": "Create comprehensive user journey flows for different user types. Implement distinct experiences for public users, logged-in patients, and healthcare providers.",
            "status": "pending",
            "dependencies": [
              11
            ],
            "details": "Implement user journey flows for different user types:\n- Public users: Landing page → Centers link in top nav → Public Finder\n- Logged-in patients: Dashboard → Find Center card → Public Finder with preferences pre-filled\n- Logged-in providers: Sidebar → Find Centers → Public Finder with clinical filters pre-selected\n- Referral flow integration: \"Find Center\" button in referral creation process\n- Context preservation: Maintain user context and preferences across navigation\n- State persistence: Preserve search state and selections between sessions\n- Personalization: Adapt experience based on user role and preferences\n- Seamless transitions: Ensure smooth navigation between different parts of the app\n- Error handling: Provide helpful guidance for failed journeys\n- Accessibility: Ensure all journeys are accessible to all users\n\nJourney implementation:\n- Public user flow: Implement standalone access without authentication\n- Patient flow: Pre-fill search filters based on patient preferences\n- Provider flow: Pre-select clinical filters and specialty options\n- Referral integration: Connect to existing referral creation workflow\n- Context management: Implement proper state management for user context\n- Preference storage: Save and restore user preferences and search history\n- Error recovery: Provide clear paths for users who encounter issues\n- Success paths: Guide users to next steps after finding centers\n- Mobile optimization: Ensure all journeys work on mobile devices\n- Performance optimization: Optimize journey performance and loading",
            "testStrategy": "Test user journey flows functionality:\n- Verify public user journey works without authentication\n- Test patient journey with pre-filled preferences\n- Validate provider journey with clinical filters\n- Test referral flow integration and context preservation\n- Verify context preservation across navigation\n- Test state persistence between sessions\n- Validate personalization based on user role\n- Test seamless transitions between app sections\n- Verify error handling and recovery paths\n- Test accessibility across all journey types\n- Validate mobile optimization for all journeys\n- Test performance and loading optimization\n- Verify preference storage and restoration\n- Test error recovery and guidance"
          },
          {
            "id": 13,
            "title": "Develop integration points with other application features",
            "description": "Create comprehensive integration points between Public Finder and other application features. Connect to appointment booking, Referral Wizard, user preferences, and future features.",
            "status": "pending",
            "dependencies": [
              12
            ],
            "details": "Develop integration points with other application features:\n- Appointment booking flow: Connect \"Book Now\" buttons to appointment creation\n- Referral Wizard integration: Pre-populate Referral Wizard with center selection\n- User preferences system: Save and restore favorite centers and search preferences\n- Slot picker integration: Connect to existing slot selection workflow\n- Review system integration: Prepare for future center review functionality\n- Favorite lists: Enable users to save and manage favorite centers\n- State persistence: Maintain state across different application sections\n- Navigation coordination: Ensure seamless transitions between features\n- Data consistency: Maintain data consistency across all integrated features\n- Future extensibility: Design integration points for upcoming features\n\nIntegration implementation:\n- Connect center profile \"Book Now\" buttons to appointment flow\n- Implement Referral Wizard pre-population with center data\n- Create user preferences storage and retrieval system\n- Integrate with existing slot selection and booking workflow\n- Implement favorite center management functionality\n- Create state persistence across application sections\n- Ensure proper data flow between integrated features\n- Implement error handling for integration failures\n- Add loading states for integration operations\n- Create fallback mechanisms for integration issues\n- Implement proper validation for integrated data\n- Add analytics tracking for integration usage",
            "testStrategy": "Test integration points functionality:\n- Verify appointment booking flow integration works correctly\n- Test Referral Wizard pre-population with center data\n- Validate user preferences system saves and restores correctly\n- Test slot picker integration and workflow\n- Verify favorite center management functionality\n- Test state persistence across application sections\n- Validate data consistency across integrated features\n- Test error handling for integration failures\n- Verify loading states for integration operations\n- Test fallback mechanisms for integration issues\n- Validate data validation for integrated features\n- Test analytics tracking and reporting\n- Verify future extensibility of integration points\n- Test integration performance and reliability"
          }
        ]
      },
      {
        "id": 17,
        "title": "Email Intake to Draft Referral Queue Implementation",
        "description": "Implement a queue system for processing emails sent to referrals@mriguys.com, with functionality to parse email content, display draft referrals, and promote drafts to full referrals. All AI functionality must be mocked/simulated for the demo app.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "details": "1. Create a new `DraftReferrals` data model with fields for:\n   - ID, timestamp, status\n   - Email metadata (from, to, subject, received date)\n   - Parsed patient information (name, DOB if available)\n   - Parsed clinical information (modality, body part)\n   - Attachment references\n\n2. Implement email parsing logic using mocked AI functionality:\n   - Create utility functions to extract patient name patterns using predefined rules\n   - Implement modality/body part detection using simple keyword matching and heuristics\n   - Build attachment handling with placeholder functionality for prototype\n   - Ensure all parsing logic is deterministic and rule-based (no real AI services)\n\n3. Design and implement the Draft Referrals Queue UI:\n   - Create a filterable table component showing parsed email content\n   - Include columns for timestamp, patient name, modality, body part, attachments\n   - Add status indicators (new, reviewed, promoted, rejected)\n   - Implement sorting and filtering capabilities\n\n4. Build the \"Promote to Referral\" action:\n   - Create a button/action in each row to promote draft to referral\n   - Implement logic to pre-populate the Referral Wizard with parsed data\n   - Handle attachment transfer to the new referral\n\n5. Integrate with existing referral creation flow:\n   - Ensure the pre-populated Referral Wizard follows the same validation rules\n   - Update the draft status when promoted to referral\n   - Create bidirectional references between drafts and created referrals\n\n6. Add placeholder email intake simulation for the prototype:\n   - Create a mock email generator with predefined templates for testing\n   - Add a \"Simulate New Email\" button for demo purposes\n   - Implement simulated \"intelligent\" parsing that appears AI-driven but uses simple rules\n\n7. Ensure all \"intelligent\" features are completely mocked:\n   - Any smart categorization should use predefined rules\n   - Draft suggestions should be deterministic based on email content patterns\n   - The system should run completely offline with no external AI API dependencies\n   - Use existing mock data structures to simulate intelligent behavior\n\nExample Draft Referrals Table Component:\n```tsx\n// src/components/referrals/DraftReferralsTable.tsx\nimport { useState } from 'react';\nimport { Table, TableHeader, TableRow, TableCell } from '@/components/ui/table';\nimport { Button } from '@/components/ui/button';\nimport { useDraftReferrals } from '@/hooks/useDraftReferrals';\nimport { formatDate } from '@/lib/utils';\n\nexport function DraftReferralsTable() {\n  const { drafts, promoteDraft, rejectDraft } = useDraftReferrals();\n  const [filter, setFilter] = useState('');\n  \n  const filteredDrafts = drafts.filter(draft => \n    draft.patientName.toLowerCase().includes(filter.toLowerCase()) ||\n    draft.modality.toLowerCase().includes(filter.toLowerCase()) ||\n    draft.bodyPart.toLowerCase().includes(filter.toLowerCase())\n  );\n  \n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between\">\n        <input \n          type=\"text\" \n          placeholder=\"Filter drafts...\" \n          value={filter} \n          onChange={(e) => setFilter(e.target.value)}\n          className=\"px-3 py-2 border rounded-md\"\n        />\n        <Button onClick={() => simulateNewEmail()}>\n          Simulate New Email\n        </Button>\n      </div>\n      \n      <Table>\n        <TableHeader>\n          <TableRow>\n            <TableCell>Received</TableCell>\n            <TableCell>Patient</TableCell>\n            <TableCell>Modality</TableCell>\n            <TableCell>Body Part</TableCell>\n            <TableCell>Attachments</TableCell>\n            <TableCell>Actions</TableCell>\n          </TableRow>\n        </TableHeader>\n        <TableBody>\n          {filteredDrafts.map(draft => (\n            <TableRow key={draft.id}>\n              <TableCell>{formatDate(draft.receivedAt)}</TableCell>\n              <TableCell>{draft.patientName}</TableCell>\n              <TableCell>{draft.modality}</TableCell>\n              <TableCell>{draft.bodyPart}</TableCell>\n              <TableCell>{draft.attachments.length}</TableCell>\n              <TableCell>\n                <div className=\"flex space-x-2\">\n                  <Button \n                    variant=\"primary\" \n                    onClick={() => promoteDraft(draft.id)}\n                  >\n                    Promote to Referral\n                  </Button>\n                  <Button \n                    variant=\"outline\" \n                    onClick={() => rejectDraft(draft.id)}\n                  >\n                    Reject\n                  </Button>\n                </div>\n              </TableCell>\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n    </div>\n  );\n}",
        "testStrategy": "1. Test email parsing functionality:\n   - Create unit tests for the email parsing utilities\n   - Test with various email formats to verify patient name extraction\n   - Validate modality and body part detection accuracy\n   - Verify attachment handling logic\n   - Ensure all parsing logic works without external AI services\n\n2. Test Draft Referrals Queue UI:\n   - Verify that the table displays all draft referrals correctly\n   - Test filtering and sorting functionality\n   - Ensure status indicators update appropriately\n   - Validate responsive design on different screen sizes\n\n3. Test \"Promote to Referral\" functionality:\n   - Verify that clicking the action opens the Referral Wizard\n   - Confirm that parsed data is correctly pre-populated in the wizard\n   - Test the complete flow from draft to created referral\n   - Validate that attachments are properly transferred\n\n4. Test integration with existing referral flow:\n   - Ensure the pre-populated wizard follows validation rules\n   - Verify that draft status updates when promoted\n   - Test bidirectional references between drafts and referrals\n\n5. Test mocked AI functionality:\n   - Verify that all \"intelligent\" features work completely offline\n   - Test that parsing results are deterministic for the same input\n   - Validate that the simulated AI behavior is convincing for demo purposes\n   - Ensure no external API calls are made during any part of the process\n\n6. End-to-end testing:\n   - Create a test script that simulates the entire flow from email intake to referral creation\n   - Test edge cases like malformed emails, missing information, and duplicate emails\n   - Verify that the UI handles empty states and loading states correctly\n\n7. Accessibility testing:\n   - Test keyboard navigation throughout the draft referrals interface\n   - Verify screen reader compatibility\n   - Check color contrast for status indicators",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "OpenAPI YAML and API Documentation Page Implementation",
        "description": "Create a comprehensive OpenAPI YAML specification for all mock endpoints and implement a dedicated API documentation page accessible from the top navigation bar with interactive testing capabilities.",
        "details": "1. Create a comprehensive OpenAPI YAML specification:\n   - Document all endpoints from the MSW handlers:\n     - Public endpoints: `/centers`, `/centers/:id/availability`, etc.\n     - Referral/booking endpoints: `/referrals`, `/slots/hold`, `/appointments`\n     - Reports/images endpoints: `/reports/:id`, `/images/:id/download`\n     - Attorney/funder endpoints\n     - System endpoints\n   - Include detailed schemas for request/response objects\n   - Document query parameters, path parameters, and request bodies\n   - Add descriptions for all endpoints and parameters\n   - Include example values that match the seed data\n\n2. Implement API documentation page:\n   - Create a new route `/api-docs` for the documentation\n   - Add a link in the top navigation bar labeled \"API Docs\"\n   - Use Swagger UI or ReDoc for rendering the OpenAPI specification\n   - Implement responsive layout for the documentation page\n   - Ensure the page works within the existing layout shell\n\n3. Add interactive testing capabilities:\n   - Configure Swagger UI to allow \"Try it out\" functionality\n   - Connect the interactive testing to MSW handlers\n   - Ensure example responses match the seed data\n   - Add copy button for code snippets in multiple languages\n\n4. Organize documentation for clarity:\n   - Group endpoints by functional area\n   - Add tags for filtering\n   - Include authentication requirements for each endpoint\n   - Document error responses and status codes\n\n5. Integrate with existing navigation:\n   - Add API Docs link to the top bar component\n   - Ensure proper styling and active state\n   - Consider adding a keyboard shortcut for quick access\n\nExample OpenAPI YAML structure:\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: MRI Guys API\n  version: 1.0.0\n  description: API documentation for MRI Guys platform\npaths:\n  /centers:\n    get:\n      summary: Get all imaging centers\n      tags:\n        - Public\n      parameters:\n        - name: lat\n          in: query\n          description: Latitude for location-based search\n          schema:\n            type: number\n        - name: lng\n          in: query\n          description: Longitude for location-based search\n          schema:\n            type: number\n      responses:\n        '200':\n          description: List of imaging centers\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Center'\n              example:\n                - id: 1\n                  name: \"Downtown Imaging\"\n                  address: \"123 Main St\"\n                  # ... more fields matching seed data\n```",
        "testStrategy": "1. Validate OpenAPI YAML specification:\n   - Use a linter to verify the YAML syntax is correct\n   - Validate against the OpenAPI 3.0 schema\n   - Ensure all endpoints from MSW handlers are documented\n   - Verify that schemas match the actual data structures\n\n2. Test API documentation page rendering:\n   - Verify the page loads correctly at `/api-docs` route\n   - Test responsive behavior on different screen sizes\n   - Check that all endpoints are properly displayed and grouped\n   - Ensure the page is accessible and keyboard navigable\n   - Test in different browsers (Chrome, Firefox, Safari)\n\n3. Test interactive functionality:\n   - Verify \"Try it out\" feature works for all endpoints\n   - Test that example requests generate appropriate responses\n   - Validate that responses match the expected seed data\n   - Test error scenarios (invalid input, missing parameters)\n   - Verify code snippets are correctly generated and can be copied\n\n4. Test navigation integration:\n   - Verify API Docs link appears in the top navigation bar\n   - Test that clicking the link navigates to the documentation page\n   - Check that the active state is applied correctly when on the docs page\n   - Test any keyboard shortcuts for accessing the documentation\n\n5. Cross-functional testing:\n   - Verify documentation works in both light and dark themes\n   - Test with screen readers for accessibility\n   - Ensure documentation is printable if needed\n   - Validate that changes to seed data are reflected in the examples",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Webhook Simulation Panel Implementation",
        "description": "Implement a webhook testing interface for simulating center callbacks and system events, with a UI panel for triggering and monitoring webhook events, event logging, and integration with the existing MSW mock system.",
        "details": "1. Create a new Webhook Simulation Panel component:\n   - Design a clean, intuitive interface for webhook testing\n   - Implement tabs for different webhook event categories\n   - Add controls for configuring and triggering webhook events\n\n2. Extend the MSW setup to handle webhook simulation:\n   - Create new endpoint handlers for `/webhooks/test`\n   - Implement webhook event simulation logic\n   - Build webhook payload generators for different event types\n\n3. Implement webhook event types:\n   - Appointment status updates (created, confirmed, canceled, completed)\n   - Report events (ready, updated, signed)\n   - Center status changes (open, closed, emergency)\n   - System notifications (maintenance, updates)\n\n4. Create webhook payload templates:\n   - Design JSON schema for each webhook event type\n   - Include all relevant fields with realistic sample data\n   - Support customization of key fields before sending\n\n5. Build webhook history and logging:\n   - Create a data store for webhook event history\n   - Implement a log viewer component with filtering\n   - Add status indicators (success, failed, pending)\n   - Include timestamp, event type, and delivery status\n\n6. Implement webhook delivery simulation:\n   - Add configurable delay options\n   - Simulate different response codes\n   - Include retry logic for failed webhooks\n   - Support webhook signature verification\n\n7. Create developer documentation:\n   - Document available webhook event types\n   - Provide payload examples for each event\n   - Include integration instructions\n\n8. Add webhook testing to the developer tools section:\n   - Integrate with the API documentation page\n   - Create a dedicated webhook testing section\n   - Allow saving of webhook configurations\n\nExample webhook payload generator:\n```typescript\n// src/mocks/webhooks/payloadGenerators.ts\nexport const generateAppointmentWebhook = (\n  type: 'created' | 'confirmed' | 'canceled' | 'completed',\n  appointmentId?: string\n) => {\n  const appointment = appointmentId \n    ? db.appointments.find(a => a.id === appointmentId)\n    : getRandomAppointment();\n    \n  return {\n    event: `appointment.${type}`,\n    timestamp: new Date().toISOString(),\n    data: {\n      appointmentId: appointment.id,\n      patientName: appointment.patientName,\n      modality: appointment.modality,\n      bodyPart: appointment.bodyPart,\n      centerName: appointment.centerName,\n      scheduledTime: appointment.scheduledTime,\n      status: type,\n      // Additional fields based on event type\n      ...(type === 'canceled' && { \n        cancellationReason: 'patient_request',\n        canceledAt: new Date().toISOString()\n      }),\n      ...(type === 'completed' && {\n        completedAt: new Date().toISOString(),\n        reportAvailableAt: addHours(new Date(), 2).toISOString()\n      })\n    }\n  };\n};\n```",
        "testStrategy": "1. Test webhook simulation endpoint:\n   - Verify that `/webhooks/test` endpoint correctly handles POST requests\n   - Test with different event types and parameters\n   - Validate response format and status codes\n   - Check error handling for invalid requests\n\n2. Test webhook UI panel:\n   - Verify that all webhook event types can be selected and configured\n   - Test triggering of different webhook events\n   - Validate that payload preview updates based on configuration\n   - Ensure form validation works correctly for required fields\n\n3. Test webhook history and logging:\n   - Verify that triggered webhooks appear in the history log\n   - Test filtering and sorting of webhook history\n   - Validate that status indicators correctly reflect delivery status\n   - Check that webhook details can be expanded and viewed\n\n4. Test webhook payload generation:\n   - Verify that generated payloads match the expected schema\n   - Test customization of payload fields\n   - Validate that timestamps and IDs are correctly formatted\n   - Check that payloads contain realistic data\n\n5. Test MSW integration:\n   - Verify that webhook simulation works with the existing MSW setup\n   - Test that simulated webhooks trigger appropriate UI updates\n   - Validate that webhook delivery simulation works correctly\n   - Check that retry logic functions as expected\n\n6. Test developer experience:\n   - Verify that webhook documentation is clear and comprehensive\n   - Test copying of webhook payload examples\n   - Validate that saved webhook configurations persist\n   - Check integration with the API documentation page\n\n7. Test edge cases:\n   - Verify handling of network errors during webhook delivery\n   - Test with very large payloads\n   - Validate behavior with concurrent webhook triggers\n   - Check performance with a large history of webhook events",
        "status": "pending",
        "dependencies": [
          2,
          3,
          18
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Chart Implementation for PRD v2.2 Requirements",
        "description": "Implement four specific chart types (Utilization Heatmap, TAT Line Chart, No-Show Causes Stacked Bars, and Exposure Area Chart) using the Nivo library with theme-aware styling and responsive design.",
        "details": "1. Set up Nivo library integration with the project:\n   - Install required Nivo packages: `@nivo/core`, `@nivo/heatmap`, `@nivo/line`, `@nivo/bar`, `@nivo/area`\n   - Create a shared chart theme configuration that connects to the application's theming system\n\n2. Implement Utilization Heatmap chart:\n   - Create a `UtilizationHeatmap` component using Nivo's heatmap visualization\n   - Map calendar weeks to X-axis and centers to Y-axis\n   - Implement color gradient based on occupancy percentage\n   - Connect to mock data from the data store for center utilization\n\n3. Implement TAT Line Chart:\n   - Create a `TATLineChart` component using Nivo's line chart\n   - Display turnaround time trends by center over selectable time periods (7/30 days)\n   - Add toggle for switching between time periods\n   - Implement proper date formatting on the X-axis\n\n4. Implement No-Show Causes Stacked Bars:\n   - Create a `NoShowStackedBar` component using Nivo's bar chart\n   - Configure for stacked bar visualization showing breakdown of no-show reasons\n   - Implement tooltips showing percentage and count for each reason\n   - Add legend for different no-show categories\n\n5. Implement Exposure Area Chart:\n   - Create an `ExposureAreaChart` component using Nivo's area chart\n   - Display funding exposure over time with proper area visualization\n   - Add gradient fills for visual appeal\n   - Implement date range selector for time period adjustment\n\n6. Create a shared chart theming system:\n   - Define CSS variables for chart colors (--chart-1, --chart-2, etc.)\n   - Create a theme provider that maps these variables to Nivo theme properties\n   - Implement theme switching logic to update chart colors based on light/dark mode\n   - Ensure consistent color application across all chart types\n\n7. Implement responsive design for all charts:\n   - Create responsive containers that adjust chart dimensions based on viewport\n   - Define breakpoints for different device sizes\n   - Adjust label density and tooltip behavior for smaller screens\n   - Test and optimize for mobile, tablet, and desktop views\n\n8. Connect charts to the mock data store:\n   - Create data transformation utilities to format raw data for each chart type\n   - Implement data fetching hooks that connect to MSW endpoints\n   - Add loading states and error handling for data fetching\n   - Ensure data updates trigger chart re-renders\n\nExample chart component structure:\n```tsx\n// src/components/charts/UtilizationHeatmap.tsx\nimport { ResponsiveHeatMap } from '@nivo/heatmap';\nimport { useTheme } from '../../hooks/useTheme';\nimport { useCenterUtilization } from '../../hooks/useCenterUtilization';\n\nexport const UtilizationHeatmap = () => {\n  const { theme } = useTheme();\n  const { data, isLoading, error } = useCenterUtilization();\n  \n  if (isLoading) return <ChartSkeleton />;\n  if (error) return <ChartError message={error.message} />;\n  \n  return (\n    <div className=\"chart-container\">\n      <ResponsiveHeatMap\n        data={data}\n        margin={{ top: 60, right: 90, bottom: 60, left: 90 }}\n        valueFormat=\">-.2%\"\n        axisTop={{\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: -45,\n          legend: 'Calendar Week',\n          legendOffset: 46\n        }}\n        axisLeft={{\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: 0,\n          legend: 'Center',\n          legendPosition: 'middle',\n          legendOffset: -72\n        }}\n        colors={{\n          type: 'sequential',\n          scheme: 'blues',\n          minValue: 0,\n          maxValue: 1\n        }}\n        emptyColor=\"#eeeeee\"\n        theme={{\n          textColor: theme === 'dark' ? '#ffffff' : '#333333',\n          tooltip: {\n            container: {\n              background: theme === 'dark' ? '#333333' : '#ffffff',\n              color: theme === 'dark' ? '#ffffff' : '#333333',\n            }\n          }\n        }}\n        hoverTarget=\"cell\"\n        cellHoverOthersOpacity={0.25}\n      />\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit test chart components:\n   - Create Jest tests for each chart component\n   - Mock the data hooks to provide test data\n   - Verify that components render without errors\n   - Test theme switching logic and color application\n   - Validate responsive behavior using different viewport sizes\n\n2. Test Utilization Heatmap:\n   - Verify correct rendering of calendar weeks and centers\n   - Test color gradient application based on occupancy values\n   - Validate tooltip information accuracy\n   - Check axis labels and formatting\n   - Test interaction behavior (hover states, etc.)\n\n3. Test TAT Line Chart:\n   - Verify line rendering for multiple centers\n   - Test time period toggle functionality (7/30 days)\n   - Validate date formatting on X-axis\n   - Check legend accuracy and interaction\n   - Test responsive behavior on different screen sizes\n\n4. Test No-Show Causes Stacked Bars:\n   - Verify correct stacking of bar segments\n   - Test tooltip information for each segment\n   - Validate legend rendering and accuracy\n   - Check color application for different categories\n   - Test interaction with bar segments\n\n5. Test Exposure Area Chart:\n   - Verify area rendering and gradient fills\n   - Test date range selector functionality\n   - Validate Y-axis formatting for currency values\n   - Check tooltip information accuracy\n   - Test responsive behavior\n\n6. Test theme integration:\n   - Switch between light and dark themes\n   - Verify that chart colors update correctly\n   - Test CSS variable mapping to chart colors\n   - Validate contrast ratios for accessibility\n   - Check transition animations during theme changes\n\n7. Test data integration:\n   - Mock different data scenarios using MSW\n   - Verify loading states render correctly\n   - Test error handling and error state UI\n   - Validate data transformation logic\n   - Check that charts update when data changes\n\n8. Cross-browser and device testing:\n   - Test on Chrome, Firefox, Safari, and Edge\n   - Verify mobile rendering on iOS and Android\n   - Test touch interactions on mobile devices\n   - Validate tablet layout and interactions\n   - Check performance metrics on lower-end devices\n\n9. Accessibility testing:\n   - Verify color contrast meets WCAG standards\n   - Test keyboard navigation for interactive elements\n   - Check screen reader compatibility\n   - Validate ARIA attributes on chart elements\n   - Test with zoom settings at different levels",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-21T09:56:18.034Z",
      "updated": "2025-08-27T08:54:10.872Z",
      "description": "Tasks for master context"
    }
  }
}